    % 5 Environnement de développement
    %       - app:cmake_super

    % 6 Algorithmes MDCT de référence
    %   6.2 Implémentations des MDCT de référence en algorithmiques floating point et fixed point
    %       - app:mdct_const
    %       - app:mdct_ref
    %           - app:mdct_ref_float
    %           - app:mdct_ref_int
    %   6.3 Validation des algorithmes de référence
    %       - app:sin_wave
    %           - app:sin_wave_float
    %           - app:sin_wave_int

    % 7 Algorithme MDCT basé sur la FFT
    %   7.2 Implémentation de la MDCT basée sur la FFT de la librairie FFTW3
    %       - app:mdct_fftw3_f32
    %           - app:mdct_fftw3_f32_header
    %           - app:mdct_fftw3_f32_constructor
    %           - app:mdct_fftw3_f32_destructor
    %           - app:mdct_fftw3_f32_func
    %   7.3 Validation
    %       - app:fftw3_example
    %           - app:fftw3_example_code
    %           - app:fftw3_example_compilation
    %       renvoi à la section qui cite
    %           - app:spectrum_comparison
    %           - app:cmake_comp_mdct_float
    %   

    % 8 Intégration de la librairie Ne10
    %   8.2 Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique floating point
    %       - app:mdct_ne10_f32
    %           - app:mdct_ne10_f32_header
    %           - app:mdct_ne10_f32_constructor
    %           - app:mdct_ne10_f32_destructor
    %           - app:mdct_ne10_f32_func
    %   8.3 Validation
    %       renvoi à la section qui cite
    %           - app:spectrum_comparison
    %           - app:cmake_comp_mdct_float
    %   8.4 Performances
    %       - app:perf_fft_ne10
    %           - app:perf_fft_ne10_code
    %           - app:perf_fft_ne10_cmake
    %       - app:perf_fft_fftw3
    %           - app:perf_fft_fftw3_code
    %           - app:perf_fft_fftw3_cmake

    % 9 Algorithme MDCT en arithmétique fixed point
    %   9.3 Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique fixed point
    %       - app:mdct_ne10_i32_c
    %           - app:mdct_ne10_i32_c_header
    %           - app:mdct_ne10_i32_c_constructor
    %           - app:mdct_ne10_i32_c_destructor
    %           - app:mdct_ne10_i32_c_func

    % 10 Optimisations à l’architecture ARM
    %   10.3 Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique fixed point avec opérations SIMD Neon
    %       - app:mdct_ne10_i32_neon
    %       - app:mdct_ne10_i32_neon_header
    %       - app:mdct_ne10_i32_neon_constructor
    %       - app:mdct_ne10_i32_neon_destructor
    %       - app:mdct_ne10_i32_neon_func

    % 11 Analyse des résultats
    %   11.1 Validation des données
    %           - app:spectrum_comparison
    %               - app:spectrum_comparison_code
    %               - app:cmake_comp_mdct_float
    %               - app:cmake_comp_mdct_float_int
    %               - app:cmake_comp_mdct_i32_c
    %               - app:cmake_comp_mdct_i32_neon
    %   11.2 Gain en performance
    %       - app:cmake_perf_mdct_fftw3_f32
    %       - app:cmake_perf_mdct_ne10_f32
    %       - app:cmake_perf_mdct_ne10_i32_c
    %       - app:cmake_perf_mdct_ne10_i32_neon
    %       - app:cmake_perf_mdct_ref
    %   11.3 Perte de précision
    %           - app:spectrum_comparison
    %           - app:cmake_comp_mdct_float
    %           - app:cmake_comp_mdct_float_int
    %           - app:cmake_comp_mdct_i32_c
    %           - app:cmake_comp_mdct_i32_neon

\documentclass{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{moreverb}       % verbatim with tab
\usepackage{libertine}
\usepackage[libertine]{newtxmath}
\renewcommand\ttdefault{cmvtt}

\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{hmargin=2.5cm}
\usepackage{amsmath}
\usepackage{siunitx}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{lscape}

\AtBeginDocument{
    \def\labelitemi{\textbullet}    % Redéfinition des puces dans les itemize
    \renewcommand{\times}{\text{×}} % Remplacer le gros «X» par un plus beau
    %\interfootnotelinepenalty=10000
}

% Code style:
% https://texdoc.org/serve/listings.pdf/0
\usepackage{listings}
\lstset{%
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}


\begin{document}
\pagenumbering{gobble}
\renewcommand{\contentsname}{Liste des annexes}
\tableofcontents

\newpage
\setcounter{page}{1}
\pagenumbering{Roman}
\renewcommand{\thesection}{\Alph{section}}

\section{Raspberry Pi 4 CPU info}\label{app:cpuinfo}
\paragraph{}
Informations sur les CPU du Raspberry Pi 4 contenues dans le fichier \texttt{/proc/cpuinfo}.
\lstset{language=bash}
\begin{lstlisting}
$ cat /proc/cpuinfo
processor       : 0
model name      : ARMv7 Processor rev 3 (v7l)
BogoMIPS        : 108.00
Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae
 evtstrm crc32 
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x0
CPU part        : 0xd08
CPU revision    : 3

processor       : 1
model name      : ARMv7 Processor rev 3 (v7l)
BogoMIPS        : 108.00
Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae
 evtstrm crc32 
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x0
CPU part        : 0xd08
CPU revision    : 3

processor       : 2
model name      : ARMv7 Processor rev 3 (v7l)
BogoMIPS        : 108.00
Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae
 evtstrm crc32 
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x0
CPU part        : 0xd08
CPU revision    : 3

processor       : 3
model name      : ARMv7 Processor rev 3 (v7l)
BogoMIPS        : 108.00
Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae
 evtstrm crc32 
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x0
CPU part        : 0xd08
CPU revision    : 3

Hardware        : BCM2711
Revision        : b03112
Serial          : 1000000022221a34
Model           : Raspberry Pi 4 Model B Rev 1.2
\end{lstlisting}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 5 Environnement de développement
    %       - app:cmake_super
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{CMake principal}\label{app:cmake_super}
\paragraph{}
Fichier CMake principal placé à la racine du projet. Il permet de compiler :
\begin{itemize}
    \item le projet \emph{audio\_encoding} contenant les différentes MDCT et leurs tests : les commandes CMake de ce sous-projet sont présentées dans les annexes suivantes sous le code qu'elles permettent de compiler;
    \item la librairie \emph{Ne10} : les variables suivantes sont initialisées conformément aux recommendations de la documentation pour la compilation de la librairie:
    \begin{itemize}
        \item \texttt{NE10\_LINUX\_TARGET\_ARCH} est initialisée à \texttt{armv7} (l'architecture du Raspberry Pi 4);
        \item \texttt{GNULINUX\_PLATFORM} est initialisée à \texttt{ON};
        \item \texttt{BUILD\_DEBUG} est initialisée à \texttt{ON} si le projet est compilé en mode \emph{debug}.
    \end{itemize}
\end{itemize}
\lstset{language=make}
\begin{lstlisting}
cmake_minimum_required(VERSION 3.13)

set(NE10_LINUX_TARGET_ARCH armv7)
set(GNULINUX_PLATFORM ON)
if (CMAKE_BUILD_TYPE STREQUAL "DEBUG")
    set(BUILD_DEBUG ON)
endif (CMAKE_BUILD_TYPE STREQUAL "DEBUG")

add_subdirectory(audio_encoding)
add_subdirectory(Ne10)
\end{lstlisting}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 6 Algorithmes MDCT de référence
    %   6.2 Implémentations des MDCT de référence en algorithmiques floating point et fixed point
    %       - app:mdct_const
    %       - app:mdct_ref
    %           - app:mdct_ref_float
    %           - app:mdct_ref_int
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Valeurs constantes des MDCT}\label{app:mdct_const}
\paragraph{}
Le fichier \texttt{mdct\_constants.h} rassemble les valeurs constantes des MDCT pour une fenêtre d'entrée de 1024 échantillons.
\lstset{language=C++}
\begin{lstlisting}
// Sampling frequency: 48kHz
#define FS                  48000

// Window length and derived constants
#define MDCT_WINDOW_LEN     1024
#define MDCT_M              (MDCT_WINDOW_LEN>>1)    // spectrum size
#define MDCT_M2             (MDCT_WINDOW_LEN>>2)    // fft size
#define MDCT_M4             (MDCT_WINDOW_LEN>>3)
#define MDCT_M32            (3*(MDCT_WINDOW_LEN>>2))
#define MDCT_M52            (5*(MDCT_WINDOW_LEN>>2))
\end{lstlisting}



\newpage
\section{Algorithmes de référence}\label{app:mdct_ref}
\subsection{MDCT de référence en \emph{floating point}}\label{app:mdct_ref_float}
\paragraph{}
Algorithme de référence basé sur la formule mathématique de la MDCT. Le \emph{template} permet de réaliser les calculs en \emph{float} ou en \emph{double}.
\lstset{language=C++}
\begin{lstlisting}
#include <cmath>

#include "mdct_constants.h"

template<typename FLOAT>
void ref_float_mdct(FLOAT *time_signal, FLOAT *spectrum)
{
    FLOAT scale = 2.0 / sqrt(MDCT_WINDOW_LEN);
    FLOAT factor1 = 2.0 * M_PI / static_cast<FLOAT>(MDCT_WINDOW_LEN);
    FLOAT factor2 = 0.5 + static_cast<FLOAT>(MDCT_M2);
    for (int k = 0; k < MDCT_M; ++k)
    {
        FLOAT result = 0.0;
        FLOAT factor3 = (k + 0.5) * factor1;
        for (int n = 0; n < MDCT_WINDOW_LEN; ++n)
        {
            result += time_signal[n] * cos((static_cast<FLOAT>(n) + factor2) * factor3);
        }
        spectrum[k] = scale * result;
    }
}
\end{lstlisting}

\subsection{MDCT de référence en \emph{fixed point}}\label{app:mdct_ref_int}
\paragraph{}
Algorithme de référence basé sur la formule mathématique de la MDCT. Le spectre est calculé en \emph{double} puis converti en \emph{integer} sur 32 bits en représentation Q15.
\lstset{language=C++}
\begin{lstlisting}
#include <cassert>

#include "ref_mdct.h"

void ref_int_mdct(int16_t *time_signal, int32_t *spectrum)
{
    double scale = sqrt(MDCT_WINDOW_LEN) / 2.0;     // MDCT scale (2/sqrt(WIN_LEN)) + Q15 scale
    double factor1 = 2.0 * M_PI / MDCT_WINDOW_LEN;
    double factor2 = 0.5 + MDCT_M2;
    for (int k = 0; k < MDCT_M; ++k)
    {
        double result = 0.0;
        double factor3 = (k + 0.5) * factor1;
        for (int n = 0; n < MDCT_WINDOW_LEN; ++n)
        {
            result += time_signal[n] * cos((n + factor2) * factor3);
        }
        assert(round(result*scale) == static_cast<int32_t>(round(result*scale)));
        spectrum[k] = static_cast<int32_t>(round(result/scale));
    }
}
\end{lstlisting}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %   6.3 Validation des algorithmes de référence
    %       - app:sin_wave
    %           - app:sin_wave_float
    %           - app:sin_wave_int
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Génération d'un signal sinusoïdal}\label{app:sin_wave}
\subsection{Génération d'un signal sinusoïdal en \emph{floating point}}\label{app:sin_wave_float}
\paragraph{}
Code de génération d'un signal sinusoïdal en \emph{float} ou en \emph{double}. Le \emph{template} permet de générer ces deux types de signaux avec le même code.
\lstset{language=C++}
\begin{lstlisting}
#include <cmath>

template<typename FLOAT>
void sin_float(FLOAT *out, int n_samples, double amplitude,
    double frequency, double phase_shift, int sampling_frequency)
{
    FLOAT omega = 2.0 * M_PI * frequency / static_cast<FLOAT>(sampling_frequency);
    for (int i = 0; i < n_samples; ++i)
    {
        out[i] = amplitude * sin(static_cast<FLOAT>(i) * omega + phase_shift);
    }
}
\end{lstlisting}

\subsection{Génération d'un signal sinusoïdal en \emph{fixed point}}\label{app:run_ref_mdct_fint}
\paragraph{}
La génération du signal sinusoïdal en \emph{integer} fait appel à la génération du signal sinusoïdal en \emph{double} avant de convertir le résultat en \emph{integer} (représentation Q15).
\lstset{language=C++}
\begin{lstlisting}
#include <cstring>

#include "sin_wave.h"

void sin_int(int16_t *out, int n_samples, double amplitude,
    double frequency, double phase_shift, int sampling_frequency)
{
    double scale = 1.0;
    if (abs(amplitude) < 1.0) scale *= amplitude;

    double *temp_sin = static_cast<double *>(malloc(n_samples*sizeof(double)));
    memset(temp_sin, 0, n_samples*sizeof(double));

    sin_float<double>(temp_sin, n_samples, scale, frequency, phase_shift, sampling_frequency);

    for (int i = 0; i < n_samples; ++i)
    {
        out[i] = static_cast<int16_t>(temp_sin[i]*pow(2.0, 15.0));
    }
}
\end{lstlisting}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 7 Algorithme MDCT basé sur la FFT
    %   7.2 Implémentation de la MDCT basée sur la FFT de la librairie FFTW3
    %       - app:mdct_fftw3_f32
    %           - app:mdct_fftw3_f32_header
    %           - app:mdct_fftw3_f32_constructor
    %           - app:mdct_fftw3_f32_destructor
    %           - app:mdct_fftw3_f32_func
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Implémentation de la MDCT basée sur la FFT de \emph{FFTW3}}\label{app:mdct_fftw3_f32}
\subsection{Header}\label{app:mdct_fftw3_f32_header}
\paragraph{}
Header de la classe \texttt{mdct\_fftw3\_f32} : MDCT basée sur la FFT de la librairie \emph{FFTW3} en \emph{float} (32 bits). La classe contient les structures de données \texttt{fft\_in} et \texttt{fft\_out}, le tableau de facteurs de \texttt{twiddle} utilisé pour le pre- et le post-processing et la configuration de la FFT (\texttt{fft\_plan}). L'implémentation des fonctions de ce header est présentée dans les annexes suivantes.
\lstset{language=C++}
\begin{lstlisting}
#include <fftw3.h>

#include "mdct_constants.h"

class fftw3_mdct_f32
{
    private:
    fftwf_plan fft_plan;      // FFT configuration
    fftwf_complex *fft_in;    // FFT input buffer
    fftwf_complex *fft_out;   // FFT output buffer
    float twiddle[MDCT_M];

    public:
    fftw3_mdct_f32();
    ~fftw3_mdct_f32();
    void mdct(float *time_signal, float *spectrum);
    void imdct(float *spectrum, float *time_signal);
};
\end{lstlisting}

\subsection{Constructeur}\label{app:mdct_fftw3_f32_constructor}
\paragraph{}
Initialisation de la MDCT dans le constructeur de la classe \texttt{mdct\_fftw3\_f32} :
\begin{itemize}
    \item Le tableau de \texttt{twiddle} est initialisé en \emph{float} sur 32 bits;
    \item La FFT de \emph{FFTW3} est initialisée en une dimension (pour l'audio) avec la taille de la FFT réduite à un quart de la taille de la fenêtre d'entrée par le pre-processing et avec l'option \texttt{FFTW\_MEASURE} plus lente à l'initialisation mais qui permet d'optimiser le temps d'exécution de la FFT;
    \item Les tableaux contenant les données d'entrée (\texttt{fft\_in}) et de sortie (\texttt{fft\_out}) de la FFT sont alloués dynamiquement avec la fonction de \emph{FFTW3} et ils sont passés en paramètre à la configuration de la FFT.
\end{itemize}
\lstset{language=C++}
\begin{lstlisting}
#include <cmath>

fftw3_mdct_f32::fftw3_mdct_f32()
{
    float alpha = M_PI / (8.f * MDCT_M);
    float omega = M_PI / MDCT_M;
    float scale = sqrt(sqrt(2.f / MDCT_M));

    for (int i = 0; i < MDCT_M2; ++i)
    {
        float x = omega*i + alpha;
        twiddle[2*i] = scale * cos(x);
        twiddle[2*i+1] = scale * sin(x);
    }

    fft_in = (fftwf_complex *)fftwf_malloc(sizeof(fftwf_complex) * MDCT_M2);
    fft_out = (fftwf_complex *)fftwf_malloc(sizeof(fftwf_complex) * MDCT_M2);
    fft_plan = fftwf_plan_dft_1d(MDCT_M2, fft_in, fft_out, FFTW_FORWARD, FFTW_MEASURE);
}
\end{lstlisting}

\subsection{Destructeur}\label{app:mdct_fftw3_f32_destructor}
\paragraph{}
Destructeur de la classe \texttt{mdct\_fftw3\_f32} qui permet de libérer la mémoire allouée aux tableaux d'entrée et de sortie de la FFT et à sa configuration avec les fonctions appropriées fournies par la librairie \emph{FFTW3}.
\lstset{language=C++}
\begin{lstlisting}
fftw3_mdct_f32::~fftw3_mdct_f32()
{
    fftwf_destroy_plan(fft_plan);
    fftwf_free(fft_in);
    fftwf_free(fft_out);
}
\end{lstlisting}

\subsection{Fonction MDCT}\label{app:mdct_fftw3_f32_func}
\paragraph{}
Implémentation de l'algorithme de MDCT basé sur la FFT de la librairie \emph{FFTW3} :
\begin{itemize}
    \item Initialisation du tableau d'entrée de la FFT : les opérations de \emph{pre-twiddling} permettent de réduire la fenêtre d'entrée de la FFT;
    \item Appel de la fonction FFT de \emph{FFTW3};
    \item Calcul du spectre de fréquences : les opérations de \emph{post-twiddling} permettent de calculer le spectre à partir des données de sortie de la FFT et des facteurs de \emph{twiddle}.
\end{itemize}
\lstset{language=C++}
\begin{lstlisting}
void fftw3_mdct_f32::mdct(float *time_signal, float *spectrum)
{
    float *cos_tw = twiddle;
    float *sin_tw = cos_tw + 1;

    /* odd/even folding and pre-twiddle */
    float *xr = (float *)fft_in;
    float *xi = xr + 1;

    for (int i = 0; i < MDCT_M2; i += 2)
    {
        float r0 = time_signal[MDCT_M32-1-i] + time_signal[MDCT_M32+i];
        float i0 = time_signal[MDCT_M2+i] - time_signal[MDCT_M2-1-i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        xr[i] = r0*c + i0*s;
        xi[i] = i0*c - r0*s;
    }

    for(int i = MDCT_M2; i < MDCT_M; i += 2)
    {
        float r0 = time_signal[MDCT_M32-1-i] - time_signal[-MDCT_M2+i];
        float i0 = time_signal[MDCT_M2+i] + time_signal[MDCT_M52-1-i];
\end{lstlisting}
\begin{lstlisting}

        float c = cos_tw[i];
        float s = sin_tw[i];

        xr[i] = r0*c + i0*s;
        xi[i] = i0*c - r0*s;
    }

    /* complex FFT of size MDCT_M2 */
    fftwf_execute(fft_plan);

    /* post-twiddle */
    xr = (float *)fft_out;
    xi = xr + 1;

    for (int i = 0; i < MDCT_M; i += 2)
    {
        float r0 = xr[i];
        float i0 = xi[i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        spectrum[i] = -r0*c - i0*s;
        spectrum[MDCT_M-1-i] = -r0*s + i0*c;
    }
}
\end{lstlisting}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %   7.3 Validation
    %       - app:fftw3_example
    %           - app:fftw3_example_code
    %           - app:fftw3_example_compilation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Validation de la MDCT \emph{FFTW3} en \emph{float 32}}\label{app:fftw3_example}
\subsection{Code source}\label{app:fftw3_example_code}
\paragraph{}
Test de la MDCT basée sur la FFT de \emph{FFTW3} en \emph{float 32} avec un signal d'entrée sinusoïdal à \SI{440}{\hertz} :
\begin{itemize}
    \item Génération et affichage d'un signal sinusoïdal à \SI{440}{\hertz};
    \item Calcul et affichage du spectre de fréquences de ce signal;
    \item Opération inverse de la MDCT et affichage du signal temporel calculé à partir du spectre.
\end{itemize}
\paragraph{}
Les différentes données sont écrites dans un fichier CSV afin de pouvoir les exploiter sous forme graphique.
% fichier fftw3_mdct_f32.csv
\lstset{language=C++}
\begin{lstlisting}
#include <iomanip>
#include <iostream>
#include <fstream>

#include <cstring>

#include "mdct_constants.h"
#include "fftw3_mdct_f32.h"
#include "sin_wave.h"

/**
    * @brief MDCT algorithm calling the FFT of the fftw3 library
    * Code based on https://www.dsprelated.com/showcode/196.php
    * Change the MDCT_WINDOW_LEN to test the MDCT with other spectrum sizes
    */
int main(void)
{
    // input time signal (440 Hz)
    float time_in[MDCT_WINDOW_LEN];
    sin_float(time_in, MDCT_WINDOW_LEN, 0.9, 440.0, 0.0, FS);

    // output time signal (generated by the IMDCT)
    float time_out[MDCT_WINDOW_LEN];
    memset(time_out, 0, MDCT_WINDOW_LEN*sizeof(float));

    // frequency spectrum (generated by the MDCT)
    float spectrum[MDCT_M];
    memset(spectrum, 0, MDCT_M*sizeof(float));

    // perform the MDCT and IMDCT
    fftw3_mdct_f32 fftw3_mdct;
    fftw3_mdct.mdct(time_in, spectrum);
    fftw3_mdct.imdct(spectrum, time_out);

    // print the results in CSV file
    std::ofstream csv_file;
    csv_file.open("fftw3_mdct_f32.csv");
    csv_file << "time (ms),signal in,signal out,frequency (Hz),spectrum" << std::endl;

    for (int i = 0; i < MDCT_M; ++i)
    {
        csv_file << i*1000.0/FS << "," << time_in[i] << "," << time_out[i] << ","
            << (i+1.0)*FS/MDCT_WINDOW_LEN << "," << std::abs(spectrum[i]) << "," << std::endl;
    }

    for (int i = MDCT_M; i < MDCT_WINDOW_LEN; ++i)
    {
        csv_file << i*1000.0/(FS) << "," << time_in[i] << "," << time_out[i] << "," << std::endl;
    }

    csv_file.close();

    return 0;
}
\end{lstlisting}

\subsection{Compilation}\label{app:fftw3_example_compilation}
\paragraph{}
Commandes CMake permettant de compiler le code d'exemple.
\lstset{language=make}
\begin{lstlisting}
# MDCT using the fftw3 library f32
add_executable(fftw3_mdct_f32 test/validation/fftw3_example.cpp
    src/fftw3_mdct_f32.cpp src/sin_wave.cpp)
target_link_libraries(fftw3_mdct_f32 fftw3f)
\end{lstlisting}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 8 Intégration de la librairie Ne10
    %   8.2 Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique floating point
    %       - app:mdct_ne10_f32
    %           - app:mdct_ne10_f32_header
    %           - app:mdct_ne10_f32_constructor
    %           - app:mdct_ne10_f32_destructor
    %           - app:mdct_ne10_f32_func
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Implémentation de la MDCT basée sur la FFT de \emph{Ne10} en \emph{floating point}}\label{app:mdct_ne10_f32}
\subsection{Header}\label{app:mdct_ne10_f32_header}
\paragraph{}
Header de la classe \texttt{mdct\_ne10\_f32\_c} : MDCT basée sur la FFT de la librairie \emph{Ne10} en \emph{float} (32 bits). La classe contient les structures de données \texttt{fft\_in} et \texttt{fft\_out}, le tableau de facteurs de \texttt{twiddle} utilisé pour le pre- et le post-processing et la configuration de la FFT (\texttt{cfg}). L'implémentation des fonctions de ce header est présentée dans les annexes suivantes.
\lstset{language=C++}
\begin{lstlisting}
#pragma once

#include "mdct_constants.h"
#include "NE10.h"

class ne10_mdct_f32_c
{
    private:
    ne10_fft_cfg_float32_t cfg;                                          // Ne10 configuration
    ne10_fft_cpx_float32_t fft_in[MDCT_M2]__attribute__((aligned(16)));  // Ne10 FFT input buffer
    ne10_fft_cpx_float32_t fft_out[MDCT_M2]__attribute__((aligned(16))); // Ne10 FFT output buffer
    float twiddle[MDCT_M]__attribute__((aligned(16)));                   // twiddle factors

    public:
    ne10_mdct_f32_c();
    ~ne10_mdct_f32_c();
    void mdct(float *time_signal, float *spectrum);
};
\end{lstlisting}

\subsection{Constructeur}\label{app:mdct_ne10_f32_constructor}
\paragraph{}
Initialisation de la MDCT dans le constructeur de la classe \texttt{mdct\_ne10\_f32\_c} :
\begin{itemize}
    \item Le tableau de \texttt{twiddle} est initialisé en \emph{float} sur 32 bits;
    \item La configuration de la FFT de \emph{Ne10} est initialisée en \emph{complex to complex} en \emph{float 32} avec en paramètre la taille de la fenêtre de la FFT réduite à un quart de la taille de la fenêtre d'entrée.
\end{itemize}
\lstset{language=C++}
\begin{lstlisting}
ne10_mdct_f32_c::ne10_mdct_f32_c()
{
    float alpha = M_PI / (8.0 * static_cast<float>(MDCT_M));
    float omega = M_PI / static_cast<float>(MDCT_M);
    float scale = sqrt(sqrt(2.0 / static_cast<float>(MDCT_M)));
    for (int i = 0; i < MDCT_M2; ++i) 
    {
        float x = omega * i + alpha;
        twiddle[2*i] = static_cast<float>(scale * cos(x));
        twiddle[2*i+1] = static_cast<float>(scale * sin(x));
    }

    cfg = ne10_fft_alloc_c2c_float32_c(MDCT_M2);
}
\end{lstlisting}

\subsection{Destructeur}\label{app:mdct_ne10_f32_destructor}
\paragraph{}
Destructeur de la classe \texttt{mdct\_ne10\_f32\_c} qui permet de libérer la mémoire allouée à la configuration de la FFT avec la fonction appropriée de la librairie \emph{Ne10}.
\lstset{language=C++}
\begin{lstlisting}
ne10_mdct_f32_c::~ne10_mdct_f32_c()
{
    ne10_fft_destroy_c2c_float32(cfg);
}
\end{lstlisting}

\subsection{Fonction MDCT}\label{app:mdct_ne10_f32_func}
\paragraph{}
Implémentation de l'algorithme de MDCT basé sur la FFT de la librairie \emph{Ne10} en \emph{float 32} et en \emph{plain C} :
\begin{itemize}
    \item Initialisation du tableau d'entrée de la FFT : les opérations de \emph{pre-twiddling} permettent de réduire la fenêtre d'entrée de la FFT;
    \item Appel de la fonction FFT de \emph{Ne10};
    \item Calcul du spectre de fréquences : les opérations de \emph{post-twiddling} permettent de calculer le spectre à partir des données de sortie de la FFT et des facteurs de \emph{twiddle}.
\end{itemize}
\lstset{language=C++}
\begin{lstlisting}
void ne10_mdct_f32_c::mdct(float *time_signal, float *spectrum)
{
    // pre-twiddling
    float *cos_tw = twiddle;
    float *sin_tw = cos_tw + 1;
    for (int i = 0; i < MDCT_M2; i += 2)
    {
        float r0 = time_signal[MDCT_M32-1-i] + time_signal[MDCT_M32+i];
        float i0 = time_signal[MDCT_M2+i] - time_signal[MDCT_M2-1-i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        fft_in[i/2].r = r0*c + i0*s;
        fft_in[i/2].i = i0*c - r0*s;
    }

    for (int i = MDCT_M2; i < (MDCT_M); i += 2)
    {
        float r0 = time_signal[MDCT_M32-1-i] - time_signal[-MDCT_M2+i];
        float i0 = time_signal[MDCT_M2+i] + time_signal[MDCT_M52-1-i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        fft_in[i/2].r = r0*c + i0*s;
        fft_in[i/2].i = i0*c - r0*s;
    }

    // FFT
    ne10_fft_c2c_1d_float32_c(fft_out, fft_in, cfg, 0);
\end{lstlisting}
\newpage
\begin{lstlisting}

    // post-twiddling
    for (int i = 0; i < (MDCT_M); i += 2)
    {
        float r0 = fft_out[i/2].r;
        float i0 = fft_out[i/2].i;

        float c = cos_tw[i];
        float s = sin_tw[i];

        spectrum[i] = -r0*c - i0*s;
        spectrum[(MDCT_M)-1-i] = -r0*s + i0*c;
    }
}
\end{lstlisting}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %   8.4 Performances
    %       - app:perf_fft_ne10
    %           - app:perf_fft_ne10_code
    %           - app:perf_fft_ne10_cmake
    %       - app:perf_fft_fftw3
    %           - app:perf_fft_fftw3_code
    %           - app:perf_fft_fftw3_cmake
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Mesure des performances des FFT de \emph{Ne10}}\label{app:perf_fft_ne10}
\subsection{Code source}\label{app:perf_fft_ne10_code}
\paragraph{}
Code permettant de tester la vitesse d'exécution moyenne de différentes FFT proposées par la librairie \emph{Ne10}. La moyenne est calculée sur \SI{10000000}{} d'exécutions. Les données d'entrée de la FFT sont générées aléatoirement et sont différentes pour chaque exécution. Les variables de préprocesseur définies à la compilation permettent à partir du même code de mesurer le temps d'exécution moyen avec écart type :
\begin{itemize}
    \item de la FFT \emph{complex to complex} en \emph{float 32} en \emph{plain C} ou avec les optimisations NEON;
    \item de la FFT \emph{complex to complex} en \emph{integer 32} en \emph{plain C} ou avec les optimisations NEON;
    \item de la FFT \emph{complex to complex} en \emph{integer 16} en \emph{plain C} ou avec les optimisations NEON.
\end{itemize}
\lstset{language=C++}
\begin{lstlisting}
#include <iomanip>
#include <iostream>
#include <limits>

#include <cmath>
#include <cstring>

#include "mdct_constants.h"
#include "Timers.h"
#include "NE10.h"

#ifdef F32          // 32 bits floating point arithmetic

#define INPUT_RANGE             1.8
#define INPUT_DATA              ne10_fft_cpx_float32_t
#define OUTPUT_DATA             ne10_fft_cpx_float32_t
#define FFT_CONFIG              ne10_fft_cfg_float32_t
#define DESTROY_CONFIG          ne10_fft_destroy_c2c_float32

#ifdef NEON
#define ALLOC_CONFIG            ne10_fft_alloc_c2c_float32_neon
#define PERFORM_FFT             ne10_fft_c2c_1d_float32_neon
#else
#define ALLOC_CONFIG            ne10_fft_alloc_c2c_float32_c
#define PERFORM_FFT             ne10_fft_c2c_1d_float32_c
#endif

#elif I32           // 32 bits fixed point arithmetic

#define INPUT_RANGE             std::numeric_limits<int16_t>::max()*2
#define INPUT_DATA              ne10_fft_cpx_int32_t
#define OUTPUT_DATA             ne10_fft_cpx_int32_t
#define FFT_CONFIG              ne10_fft_cfg_int32_t
#define DESTROY_CONFIG          ne10_fft_destroy_c2c_int32

#ifdef NEON
#define ALLOC_CONFIG            ne10_fft_alloc_c2c_int32_neon
#define PERFORM_FFT             ne10_fft_c2c_1d_int32_neon
#else
#define ALLOC_CONFIG            ne10_fft_alloc_c2c_int32_c
#define PERFORM_FFT             ne10_fft_c2c_1d_int32_c
#endif

#else               // 16 bits fixed point arithmetic

#define INPUT_RANGE             std::numeric_limits<int16_t>::max()*2
#define INPUT_DATA              ne10_fft_cpx_int16_t
#define OUTPUT_DATA             ne10_fft_cpx_int16_t
#define FFT_CONFIG              ne10_fft_cfg_int16_t
#define ALLOC_CONFIG            ne10_fft_alloc_c2c_int16
#define DESTROY_CONFIG          ne10_fft_destroy_c2c_int16

#ifdef NEON
#define PERFORM_FFT             ne10_fft_c2c_1d_int16_neon
#else
#define PERFORM_FFT             ne10_fft_c2c_1d_int16_c
#endif

#endif

#define RUNS            10000000
#define FFT_SCALE_FLAG  0

int main()
{
    // print which FFT will be tested
#ifdef F32
#ifdef NEON
    std::cout << "FFT Ne10 f32 NEON" << std::endl;
#else
    std::cout << "FFT Ne10 f32 plain C" << std::endl;
#endif

#elif I32
#ifdef NEON
    std::cout << "FFT Ne10 i32 NEON" << std::endl;
#else
    std::cout << "FFT Ne10 i32 plain C" << std::endl;
#endif
#else
#ifdef NEON
    std::cout << "FFT Ne10 i16 NEON" << std::endl;
#else
    std::cout << "FFT Ne10 i16 plain C" << std::endl;
#endif
#endif

    // seed the random
    srand(static_cast<unsigned>(time(0)));

    // initialize the configuration
    FFT_CONFIG cfg = ALLOC_CONFIG(MDCT_M2);

    // start the loop executing the FFTs
    int64_t *runtimes = static_cast<int64_t *>(malloc(RUNS * sizeof(int64_t)));
    for (int i = 0; i < RUNS; ++i)
    {
        // initialize an empty spectrum
        OUTPUT_DATA spectrum[MDCT_M2]__attribute__((aligned(16)));
        memset(&spectrum, 0, (MDCT_M2)*sizeof(OUTPUT_DATA));

        // generate random input data
        INPUT_DATA time_signal[MDCT_M2]__attribute__((aligned(16)));
        for (int i = 0; i < MDCT_M2; ++i)
        {
            time_signal[i].r = INPUT_RANGE * rand() / RAND_MAX - INPUT_RANGE / 2;
            time_signal[i].i = INPUT_RANGE * rand() / RAND_MAX - INPUT_RANGE / 2;
        }

        // perfom the FFT and measure the run time
        EvsHwLGPL::CTimers timer;
        timer.Start();
#ifdef F32
        PERFORM_FFT(time_signal, spectrum, cfg, 0);
#else
        PERFORM_FFT(time_signal, spectrum, cfg, 0, FFT_SCALE_FLAG);
#endif
        timer.Stop();
        runtimes[i] = timer.GetTimeElapsed();
    }

    // clean
    DESTROY_CONFIG(cfg);

    // compute the average
    double avg = 0.0;
    for (int i = 0; i < RUNS; ++i) avg += static_cast<double>(runtimes[i]);
    avg = avg / static_cast<double>(RUNS);
    std::cout << "average run time:   " << avg << " ns" << std::endl;

    // compute the standard deviation
    double dev = 0.0;
    for (int i = 0; i < RUNS; ++i) dev += static_cast<double>(runtimes[i]) - avg;
    dev = dev * dev / static_cast<double>(RUNS);
    dev = sqrt(dev);
    std::cout << "standard deviation: " << dev << " ns" << std::endl;

    return 0;
}
\end{lstlisting}

\subsection{Compilation}\label{app:perf_fft_ne10_cmake}
\paragraph{}
Commandes CMake utilisées pour générer les exécutables permettant de mesurer le temps d'exécution de différentes FFT proposées par la librairie \emph{Ne10}. En fonction des variables de préprocesseur définies, les exéctables suivants sont générés :
\begin{itemize}
    \item \texttt{run\_fft\_f32\_c} est généré si la variable \texttt{F32} est définie pour mesurer le temps d'exécution de la FFT \emph{float 32} \emph{plain C};
    \item \texttt{run\_fft\_i32\_c} est généré si la variable \texttt{I32} est définie pour mesurer le temps d'exécution de la FFT \emph{integer 32} \emph{plain C};
    \item \texttt{run\_fft\_i16\_c} est généré par défaut pour mesurer le temps d'exécution de la FFT \emph{integer 16} \emph{plain C};
    \item \texttt{run\_fft\_f32\_neon} est généré si les variables \texttt{F32} et \texttt{NEON} sont définies pour mesurer le temps d'exécution de la FFT \emph{float 32} avec optimisations NEON;
    \item \texttt{run\_fft\_i32\_neon} est généré si les variables \texttt{I32} et \texttt{NEON} sont définies pour mesurer le temps d'exécution de la FFT \emph{integer 32} avec optimisations NEON;
    \item \texttt{run\_fft\_i16\_neon} est généré si la variable \texttt{NEON} est définie pour mesurer le temps d'exécution de la FFT \emph{integer 16} avec optimisations NEON.
\end{itemize}
\lstset{language=make}
\begin{lstlisting}
# Ne10 FFT performance (float32 plain C)
add_executable(run_ne10_fft_f32_c test/performance/run_ne10_fft.cpp src/Timers.cpp)
target_compile_definitions(run_ne10_fft_f32_c PUBLIC -DF32)
target_link_libraries(run_ne10_fft_f32_c NE10)

# Ne10 FFT performance (int32 plain C)
add_executable(run_ne10_fft_i32_c test/performance/run_ne10_fft.cpp src/Timers.cpp)
target_compile_definitions(run_ne10_fft_i32_c PUBLIC -DI32)
target_link_libraries(run_ne10_fft_i32_c NE10)

# Ne10 FFT performance (int16 plain C)
add_executable(run_ne10_fft_i16_c test/performance/run_ne10_fft.cpp src/Timers.cpp)
target_compile_definitions(run_ne10_fft_i16_c PUBLIC -DI16)
target_link_libraries(run_ne10_fft_i16_c NE10)

# Ne10 FFT performance (float32 with neon optimizations)
add_executable(run_ne10_fft_f32_neon test/performance/run_ne10_fft.cpp src/Timers.cpp)
target_compile_definitions(run_ne10_fft_f32_neon PUBLIC -DF32 -DNEON)
target_link_libraries(run_ne10_fft_f32_neon NE10)

# Ne10 FFT performance (int32 with neon optimizations)
add_executable(run_ne10_fft_i32_neon test/performance/run_ne10_fft.cpp src/Timers.cpp)
target_compile_definitions(run_ne10_fft_i32_neon PUBLIC -DI32 -DNEON)
target_link_libraries(run_ne10_fft_i32_neon NE10)

# Ne10 FFT performance (int16 with neon optimizations)
add_executable(run_ne10_fft_i16_neon test/performance/run_ne10_fft.cpp src/Timers.cpp)
target_compile_definitions(run_ne10_fft_i16_neon PUBLIC -DI16 -DNEON)
target_link_libraries(run_ne10_fft_i16_neon NE10)
\end{lstlisting}



\newpage
\section{Mesure des performances des FFT de \emph{FFTW3}}\label{app:perf_fft_fftw3}
\subsection{Code source}\label{app:perf_fft_fftw3_code}
\paragraph{}
Code permettant de tester la vitesse d'exécution moyenne de la FFT en \emph{float 32} de la librairie \emph{FFTW3}. La moyenne est calculée sur \SI{10000000}{} d'exécutions. Les données d'entrée de la FFT sont générées aléatoirement et sont différentes pour chaque exécution.
\lstset{language=C++}
\begin{lstlisting}
#include <iomanip>
#include <iostream>
#include <cmath>

#include <fftw3.h>

#include "mdct_constants.h"
#include "Timers.h"

#define RUNS 10000000

int main()
{
    // print which FFT will be tested
    std::cout << "FFT FFTW3 f32 plain C" << std::endl;

    // seed the random
    srand(static_cast<unsigned>(time(0)));

    // start the loop executing the FFTs
    int64_t *runtimes = static_cast<int64_t *>(malloc(RUNS * sizeof(int64_t)));
    for (int i = 0; i < RUNS; ++i)
    {
        // initialize an empty spectrum
        fftwf_complex *fft_out = (fftwf_complex *)fftwf_malloc(sizeof(fftwf_complex) * MDCT_M2);

        // generate random input data
        fftwf_complex *fft_in = (fftwf_complex *)fftwf_malloc(sizeof(fftwf_complex) * MDCT_M2);
        float *x = (float *)fft_in;
        for (int i = 0; i < MDCT_M2; ++i)
        {
            x[i] = 1.8f * rand() / RAND_MAX - 1.8f / 2.0f;
        }

        // initialize the configuration
        fftwf_plan fft_plan = fftwf_plan_dft_1d(MDCT_M2, fft_in, fft_out,
            FFTW_FORWARD, FFTW_MEASURE);

        // perfom the FFT and measure the run time
        EvsHwLGPL::CTimers timer;
        timer.Start();
        fftwf_execute(fft_plan);
        timer.Stop();
        runtimes[i] = timer.GetTimeElapsed();

        // clean
        fftwf_destroy_plan(fft_plan);
        fftwf_free(fft_in);
        fftwf_free(fft_out);
    }

    // compute the average
    double avg = 0.0;
    for (int i = 0; i < RUNS; ++i) avg += static_cast<double>(runtimes[i]);
    avg = avg / static_cast<double>(RUNS);
    std::cout << "average run time:   " << avg << " ns" << std::endl;

    // compute the standard deviation
    double dev = 0.0;
    for (int i = 0; i < RUNS; ++i) dev += static_cast<double>(runtimes[i]) - avg;
    dev = dev * dev / static_cast<double>(RUNS);
    dev = sqrt(dev);
    std::cout << "standard deviation: " << dev << " ns" << std::endl;

    return 0;
}
\end{lstlisting}

\subsection{Compilation}\label{app:perf_fft_fftw3_cmake}
\paragraph{}
Commandes CMake utilisées pour générer l'exécutable permettant de mesurer le temps d'exécution de la FFT \emph{float 32} de la librairie \emph{FFTW3}.
\lstset{language=make}
\begin{lstlisting}
# FFTW3 FFT performance (float32)
add_executable(run_fftw3_fft_f32 test/performance/run_fftw3_fft_f32.cpp src/Timers.cpp)
target_link_libraries(run_fftw3_fft_f32 fftw3f)
\end{lstlisting}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 9 Algorithme MDCT en arithmétique fixed point
    %   9.3 Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique fixed point
    %       - app:mdct_ne10_i32_c
    %           - app:mdct_ne10_i32_c_header
    %           - app:mdct_ne10_i32_c_constructor
    %           - app:mdct_ne10_i32_c_destructor
    %           - app:mdct_ne10_i32_c_func
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Implémentation de la MDCT basée sur la FFT de \emph{Ne10} en \emph{fixed point}}\label{app:mdct_ne10_i32_c}
\subsection{Header}\label{app:mdct_ne10_i32_c_header}
\paragraph{}
Header de la classe \texttt{mdct\_ne10\_i32\_c} : MDCT basée sur la FFT de la librairie \emph{Ne10} en \emph{integer} (32 bits). La classe contient les structures de données \texttt{fft\_in} en représentation Q1.15 et \texttt{fft\_out} en Q9.15, le tableau de facteurs de \texttt{twiddle} utilisé pour le pre- et le post-processing et la configuration de la FFT (\texttt{cfg}). L'implémentation des fonctions de ce header est présentée dans les annexes suivantes.
\lstset{language=C++}
\begin{lstlisting}
#pragma once

#include "mdct_constants.h"
#include "NE10.h"

class ne10_mdct_i32_c
{
    private:
    ne10_fft_cfg_int32_t cfg;                                          // Ne10 configuration
    ne10_fft_cpx_int32_t fft_in[MDCT_M2]__attribute__((aligned(16)));  // Ne10 FFT input buffer
                                                                       //   Q1.15
    ne10_fft_cpx_int32_t fft_out[MDCT_M2]__attribute__((aligned(16))); // Ne10 FFT output buffer
                                                                       //   Q9.15
    int16_t twiddle[MDCT_M]__attribute__((aligned(16)));               // MDCT twiddle factors

    public:
    ne10_mdct_i32_c();
    ~ne10_mdct_i32_c();
    void mdct(int16_t *time_signal, int32_t *spectrum);
};
\end{lstlisting}

\subsection{Constructeur}\label{app:mdct_ne10_i32_c_constructor}
\paragraph{}
Initialisation de la MDCT dans le constructeur de la classe \texttt{mdct\_ne10\_i32\_c} :
\begin{itemize}
    \item Le tableau de \texttt{twiddle} est initialisé en \emph{double} puis converti en \emph{integer} (représentation Q15);
    \item La configuration de la FFT de \emph{Ne10} est initialisée en \emph{complex to complex} en \emph{integer 32} avec en paramètre la taille de la fenêtre de la FFT réduite à un quart de la taille de la fenêtre d'entrée.
\end{itemize}
\lstset{language=C++}
\begin{lstlisting}
ne10_mdct_i32_c::ne10_mdct_i32_c()
{
    // intialize the twiddling factors
    double alpha = M_PI / (8.0*MDCT_M);
    double omega = M_PI / MDCT_M;
    double scale = sqrt(sqrt(2.0 / static_cast<double>MDCT_M));
    for (int i = 0; i < MDCT_M2; ++i)
    {
        double x = omega * i + alpha;
        twiddle[2*i] = static_cast<int16_t>(cos(x)*scale*pow(2.0, 15.0));
        twiddle[2*i+1] = static_cast<int16_t>(sin(x)*scale*pow(2.0, 15.0));
    }

    // initialize the Ne10 FFT configuration
    cfg = ne10_fft_alloc_c2c_int32_c(MDCT_M2);
}
\end{lstlisting}

\subsection{Destructeur}\label{app:mdct_ne10_i32_c_destructor}
\paragraph{}
Destructeur de la classe \texttt{mdct\_ne10\_i32\_c} qui permet de libérer la mémoire allouée à la configuration de la FFT avec la fonction appropriée de la librairie \emph{Ne10}.
\lstset{language=C++}
\begin{lstlisting}
ne10_mdct_i32_c::~ne10_mdct_i32_c()
{
    ne10_fft_destroy_c2c_int32(cfg);
}
\end{lstlisting}

\subsection{Fonction MDCT}\label{app:mdct_ne10_i32_c_func}
\paragraph{}
Implémentation de l'algorithme de MDCT basé sur la FFT de la librairie \emph{Ne10} en \emph{integer 32} et en \emph{plain C} :
\begin{itemize}
    \item Initialisation du tableau d'entrée de la FFT : les opérations de \emph{pre-twiddling} permettant de réduire la fenêtre d'entrée de la FFT sont faites en algorithmique \emph{fixed point};
    \item Appel de la fonction FFT de \emph{Ne10};
    \item Calcul du spectre de fréquences : les opérations de \emph{post-twiddling} permettant de calculer le spectre à partir des données de sortie de la FFT et des facteurs de \emph{twiddle} sont faites en algorithmique \emph{fixed point}.
\end{itemize}
\lstset{language=C++}
\begin{lstlisting}
void ne10_mdct_i32_c::mdct(int16_t *time_signal, int32_t *spectrum)
{
    // pre-twiddling
    // fft_in = (Q1.15 + Q1.15) * Q1.15/4 + (Q1.15 + Q1.15) * Q1.15/4
    //          1/4 Q1.30 + 1/4 Q1.30 + 1/4 Q1.30 + 1/4 Q1.30 -> Q1.30
    //          >>7 -> Q1.23 + 8 bits reserved for the FFT
    int16_t *cos_tw = twiddle;
    int16_t *sin_tw = cos_tw + 1;
    for (int i = 0; i < MDCT_M2; i += 2)
    {
        int32_t r0 = static_cast<int32_t>(time_signal[MDCT_M32-1-i]) + time_signal[MDCT_M32+i];
        int32_t i0 = static_cast<int32_t>(time_signal[MDCT_M2+i]) - time_signal[MDCT_M2-1-i];

        int16_t c = cos_tw[i];
        int16_t s = sin_tw[i];

        fft_in[i/2].r = (((r0*c)+64)>>7) + (((i0*s)+64)>>7);
        fft_in[i/2].i = (((i0*c)+64)>>7) - (((r0*s)+64)>>7);
    }

    for (int i = MDCT_M2; i < MDCT_M; i += 2)
    {
        int32_t r0 = static_cast<int32_t>(time_signal[MDCT_M32-1-i]) - time_signal[-MDCT_M2+i];
        int32_t i0 = static_cast<int32_t>(time_signal[MDCT_M2+i]) + time_signal[MDCT_M52-1-i];

        int16_t c = cos_tw[i];
        int16_t s = sin_tw[i];

        fft_in[i/2].r = (((r0*c)+64)>>7) + (((i0*s)+64)>>7);
        fft_in[i/2].i = (((i0*c)+64)>>7) - (((r0*s)+64)>>7);
    }

    // perform the FFT
    ne10_fft_c2c_1d_int32_c(fft_out, fft_in, cfg, 0, 0);
\end{lstlisting}

\begin{lstlisting}

    // post-twiddling
    // spectrum = Q9.23>>8 * Q1.15/4 + Q9.23>>8 * Q1.15/4
    //          = Q9.15 * Q1.15/4 + Q9.15 * Q1.15/4
    //          = Q10.30/4 + Q10.30/4
    //          = Q11.30/4
    //          = Q9.30 >> 15 = Q9.15
    for (int i = 0; i < MDCT_M; i += 2)
    {
        int32_t r0 = fft_out[i/2].r;
        int32_t i0 = fft_out[i/2].i;

        int16_t c = cos_tw[i];
        int16_t s = sin_tw[i];

        spectrum[i] = (((-(static_cast<int64_t>(r0)+128)>>8)*c+16384)>>15) 
            - ((((static_cast<int64_t>(i0)+128)>>8)*s+16384)>>15);
        spectrum[MDCT_M-1-i] = ((((-static_cast<int64_t>(r0)+128)>>8)*s+16384)>>15) 
            + ((((static_cast<int64_t>(i0)+128)>>8)*c+16384)>>15);
    }
}
\end{lstlisting}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 10 Optimisations à l’architecture ARM
    %   10.3 Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique fixed point avec opérations SIMD Neon
    %       - app:mdct_ne10_i32_neon
    %       - app:mdct_ne10_i32_neon_header
    %       - app:mdct_ne10_i32_neon_constructor
    %       - app:mdct_ne10_i32_neon_destructor
    %       - app:mdct_ne10_i32_neon_func
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Implémentation de la MDCT basée sur la FFT de \emph{Ne10} en \emph{fixed point} avec optimisations NEON}\label{app:mdct_ne10_i32_neon}
\paragraph{}
Le code de cette annexe utilise les instructions intrinsèques NEON et doit être compilé avec l'option \texttt{-mfpu=neon}.

\subsection{Header}\label{app:mdct_ne10_i32_neon_header}
\paragraph{}
Header de la classe \texttt{mdct\_ne10\_i32\_neon} : MDCT basée sur la FFT de la librairie \emph{Ne10} en \emph{integer} (32 bits) optimisée par l'utilisation des opérations ARM NEON. La classe contient les structures de données \texttt{fft\_in} en représentation Q1.15 et \texttt{fft\_out} en Q9.15, les tableaux de facteurs de \texttt{twiddle} utilisés pour le \emph{pre-} et le \emph{post-processing} et la configuration de la FFT (\texttt{cfg}). Contrairement aux autres implémentations, les facteurs de twiddle ne sont pas rassemblés dans un seul tableau. Les tableaux de facteurs de \emph{pre-twiddling} et de \emph{post-twiddling} sont séparés car ils sont utilisés en 16 bits pour le \emph{pre-twiddling} et en 32 bits pour le \emph{post-twiddling}. Chacun de ces tableaux est séparé en deux afin que chaque moitié puisse être initialisée dans un ordre qui facilite l'utilisation des opérations SIMD. L'implémentation des fonctions de ce header est présentée dans les annexes suivantes.
\lstset{language=C++}
\begin{lstlisting}
#pragma once

#include <arm_neon.h>
#include "mdct_constants.h"
#include "NE10.h"

class ne10_mdct_i32_neon
{
private:
    ne10_fft_cfg_int32_t cfg;                                          // Ne10 configuration
    ne10_fft_cpx_int32_t fft_in[MDCT_M2]__attribute__((aligned(16)));  // Ne10 FFT input buffer
    ne10_fft_cpx_int32_t fft_out[MDCT_M2]__attribute__((aligned(16))); // Ne10 FFT output buffer
    int16_t pretwiddle_start[MDCT_M2]__attribute__((aligned(16)));     // pre-twiddle factors
    int16_t pretwiddle_end[MDCT_M2]__attribute__((aligned(16)));       // second half is stored
                                                                       //   in reversed order
    int32_t posttwiddle_start[MDCT_M2]__attribute__((aligned(16)));    // post-twiddle factors
    int32_t posttwiddle_end[MDCT_M2]__attribute__((aligned(16)));      // second half is stored
                                                                       //   in reversed order

public:
    ne10_mdct_i32_neon();
    ~ne10_mdct_i32_neon();
    void mdct(int16_t *time_signal, int32_t *spectrum);
};
\end{lstlisting}

\subsection{Constructeur}\label{app:mdct_ne10_i32_neon_constructor}
\paragraph{}
Initialisation de la MDCT dans le constructeur de la classe \texttt{mdct\_ne10\_i32\_neon} :
\begin{itemize}
    \item Les tableaux de \texttt{twiddle} sont initialisés en \emph{double} puis convertis en \emph{integer} (représentation Q15 en 16 bits pour le \emph{pre-twiddling} et en 32 bits pour le \emph{post-twiddling}) : la première moitié des tableaux est rangée à l'endroit dans les tableaux \texttt{pretwiddle\_start} et \texttt{posttwiddle\_start} tandis que la seconde est rangée à l'envers dans les tableaux \texttt{pretwiddle\_end} et \texttt{posttwiddle\_end};
    \item La configuration de la FFT de \emph{Ne10} est initialisée en \emph{complex to complex} en \emph{integer 32} avec en paramètre la taille de la fenêtre de la FFT réduite à un quart de la taille de la fenêtre d'entrée avec la fonction adaptée pour l'exécution d'une FFT optimisée avec les instructions ARM NEON.
\end{itemize}
\lstset{language=C++}
\begin{lstlisting}
ne10_mdct_i32_neon::ne10_mdct_i32_neon()
{
    double alpha = M_PI / (8.0*MDCT_M);
    double omega = M_PI / MDCT_M;
    double scale = sqrt(sqrt(2.0 / static_cast<double>MDCT_M));
    for (int i = 0; i < MDCT_M4; ++i)
    {
        double start = omega * (i) + alpha;
        double end = omega * (i+MDCT_M4) + alpha;
        double cos_start = cos(start);
        double sin_start = sin(start);
        double cos_end = cos(end);
        double sin_end = sin(end);
        pretwiddle_start[2*i] = static_cast<int16_t>(cos_start*scale*pow(2.0, 15.0));
        pretwiddle_start[2*i+1] = static_cast<int16_t>(sin_start*scale*pow(2.0, 15.0));
        pretwiddle_end[MDCT_M2-2*i-2] = static_cast<int16_t>(cos_end*scale*pow(2.0, 15.0));
        pretwiddle_end[MDCT_M2-2*i-1] = static_cast<int16_t>(sin_end*scale*pow(2.0, 15.0));
        posttwiddle_start[2*i] = static_cast<int32_t>(cos_start*scale*pow(2.0, 31.0));
        posttwiddle_start[2*i+1] = static_cast<int32_t>(sin_start*scale*pow(2.0, 31.0));
        posttwiddle_end[MDCT_M2-2*i-2] = static_cast<int32_t>(cos_end*scale*pow(2.0, 31.0));
        posttwiddle_end[MDCT_M2-2*i-1] = static_cast<int32_t>(sin_end*scale*pow(2.0, 31.0));
    }

    cfg = ne10_fft_alloc_c2c_int32_neon(MDCT_M2);
}
\end{lstlisting}

\subsection{Destructeur}\label{app:mdct_ne10_i32_neon_destructor}
\paragraph{}
Destructeur de la classe \texttt{mdct\_ne10\_i32\_c} qui permet de libérer la mémoire allouée à la configuration de la FFT avec la fonction appropriée de la librairie \emph{Ne10}.
\lstset{language=C++}
\begin{lstlisting}
ne10_mdct_i32_neon::~ne10_mdct_i32_neon()
{
    ne10_fft_destroy_c2c_int32(cfg);
}
\end{lstlisting}

\subsection{Fonction MDCT}\label{app:mdct_ne10_i32_neon_func}
\paragraph{}
Implémentation de l'algorithme de MDCT basé sur la FFT de la librairie \emph{Ne10} en \emph{integer 32} avec utilisation des instructions ARM NEON :
\begin{itemize}
    \item Initialisation du tableau d'entrée de la FFT : les opérations de \emph{pre-twiddling} permettant de réduire la fenêtre d'entrée de la FFT sont faites en algorithmique \emph{fixed point}. L'utilisation des fonctions SIMD permet d'effectuer quatre opérations en parallèle afin de réduire le temps d'exécution. Les facteurs de \emph{pre-twiddling} codés sur 16 bits transforment le signal d'entrée codé sur \emph{16 bits} en un tableau d'entrée de la FFT codé sur 32 bits;
    \item Appel de la fonction FFT de \emph{Ne10} optimisée par l'utilisation des instructions ARM NEON;
    \item Calcul du spectre de fréquences : les opérations de \emph{post-twiddling} permettant de calculer le spectre à partir des données de sortie de la FFT et des facteurs de \emph{twiddle} sont faites en algorithmique \emph{fixed point}. Les fonctions SIMD permettent d'effectuer deux ou quatre opérations en parallèle afin de réduire le temps d'exécution.
\end{itemize}
\lstset{language=C++}
\newpage
\begin{lstlisting}
void ne10_mdct_i32_neon::mdct(int16_t *time_signal, int32_t *spectrum)
{
    // see the twiddling_loops.nlsx file for more details
    
    // for i from 0 to 254, step 2

    // r[  0 -> 127, pas 1] =  time_signal[ 767 ->  513, pas 2] * c[  0 -> 127, pas 1]
    //                      +  time_signal[ 768 -> 1022, pas 2] * c[  0 -> 127, pas 1]
    //                      +  time_signal[ 256 ->  510, pas 2] * s[  0 -> 127, pas 1]
    //                      + -time_signal[ 255 ->    1, pas 2] * s[  0 -> 127, pas 1]

    // i[  0 -> 127, pas 1] =  time_signal[ 256 ->  510, pas 2] * c[  0 -> 127, pas 1]
    //                      + -time_signal[ 255 ->    1, pas 2] * c[  0 -> 127, pas 1]
    //                      + -time_signal[ 767 ->  513, pas 2] * s[  0 -> 127, pas 1]
    //                      + -time_signal[ 768 -> 1022, pas 2] * s[  0 -> 127, pas 1]

    // fft_in[i/2].r = time_signal[M32-1-i]    * cos_tw[i] + time_signal[M32+i]     * cos_tw[i]
    //               + time_signal[M2+i]       * sin_tw[i] + (-time_signal[M2-1-i]) * sin_tw[i]

    // fft_in[i/2].i = time_signal[M2+i]       * cos_tw[i] + (-time_signal[M2-1-i]) * cos_tw[i]
    //               + (-time_signal[M32-1-i]) * sin_tw[i] + (-time_signal[M32+i])  * sin_tw[i]


    // for i from 510 to 256, step 2

    // r[255 -> 128, pas 1] =  time_signal[ 257 ->  511, pas 2] * c[255 -> 128, pas 1]
    //                      + -time_signal[ 254 ->    0, pas 2] * c[255 -> 128, pas 1]
    //                      +  time_signal[ 766 ->  512, pas 2] * s[255 -> 128, pas 1]
    //                      +  time_signal[ 769 -> 1023, pas 2] * s[255 -> 128, pas 1]

    // i[255 -> 128, pas 1] =  time_signal[ 766 ->  512, pas 2] * c[255 -> 128, pas 1]
    //                      +  time_signal[ 769 -> 1023, pas 2] * c[255 -> 128, pas 1]
    //                      + -time_signal[ 257 ->  511, pas 2] * s[255 -> 128, pas 1]
    //                      +  time_signal[ 254 ->    0, pas 2] * s[255 -> 128, pas 1]

    // fft_in[i/2].r = time_signal[M32-1-i]    * cos_tw[i] + (-time_signal[-M2+i]) * cos_tw[i]
    //               + time_signal[M2+i]       * sin_tw[i] + time_signal[M52-1-i]  * sin_tw[i]

    // fft_in[i/2].i = time_signal[M2+i]       * cos_tw[i] + time_signal[M52-1-i] * cos_tw[i]
    //               + (-time_signal[M32-1-i]) * sin_tw[i] + time_signal[-M2+i]   * sin_tw[i]

    for (int i = 0; i < MDCT_M2; i += 8)
    {
        // tx.val[0] -> odd indexes
        // tx.val[1] -> even indexes
        int16x4x2_t t1 = vld2_s16(time_signal+MDCT_M2+i);
        int16x4x2_t t2 = vld2_s16(time_signal+MDCT_M2-8-i);
        int16x4x2_t t3 = vld2_s16(time_signal+MDCT_M32+i);
        int16x4x2_t t4 = vld2_s16(time_signal+MDCT_M32-8-i);

        t2.val[0] = (int16x4_t)vrev64_s32((int32x2_t)vrev32_s16(t2.val[0]));
                                                // reverse the t2 even values: 0 2 4 6 -> 6 4 2 0
        t2.val[1] = (int16x4_t)vrev64_s32((int32x2_t)vrev32_s16(t2.val[1]));
                                                // reverse the t2 odd values : 1 3 5 7 -> 7 5 3 1
        t4.val[0] = (int16x4_t)vrev64_s32((int32x2_t)vrev32_s16(t4.val[0]));
                                                // reverse the t4 even values: 0 2 4 6 -> 6 4 2 0
        t4.val[1] = (int16x4_t)vrev64_s32((int32x2_t)vrev32_s16(t4.val[1]));
                                                // reverse the t4 odd values : 1 3 5 7 -> 7 5 3 1
\end{lstlisting}
\begin{lstlisting}
        // x_tw.val[0] -> cos twiddle
        // x_tw.val[1] -> sin twiddle
        int16x4x2_t start_tw = vld2_s16(pretwiddle_start+i);
        int16x4x2_t end_tw = vld2_s16(pretwiddle_end+i);

        // start.val[0] -> real part
        // start.val[1] -> imaginary part
        int32x4x2_t start;
        start.val[0] = vshrq_n_s32(
            vaddq_s32(
                vaddq_s32(
                    vmull_s16(t4.val[1], start_tw.val[0]),
                    vmull_s16(t3.val[0], start_tw.val[0])),
                vaddq_s32(
                    vmull_s16(t1.val[0], start_tw.val[1]),
                    vmull_s16(vneg_s16(t2.val[1]), start_tw.val[1])))
                , 7);
        start.val[1] = vshrq_n_s32(
            vaddq_s32(
                vaddq_s32(
                    vmull_s16(t1.val[0], start_tw.val[0]),
                    vmull_s16(vneg_s16(t2.val[1]), start_tw.val[0])),
                vaddq_s32(
                    vmull_s16(vneg_s16(t4.val[1]), start_tw.val[1]),
                    vmull_s16(vneg_s16(t3.val[0]), start_tw.val[1])))
                , 7);

        // end.val[0] -> real part
        // end.val[1] -> imaginary part
        int32x4x2_t end;
        end.val[0] = vshrq_n_s32(
            vaddq_s32(
                vaddq_s32(
                    vmull_s16(t1.val[1], end_tw.val[0]),
                    vmull_s16(vneg_s16(t2.val[0]), end_tw.val[0])),
            vaddq_s32(
                vmull_s16(t4.val[0], end_tw.val[1]),
                vmull_s16(t3.val[1], end_tw.val[1])))
            , 7);
        end.val[1] = vshrq_n_s32(
            vaddq_s32(
                vaddq_s32(
                    vmull_s16(t4.val[0], end_tw.val[0]),
                    vmull_s16(t3.val[1], end_tw.val[0])),
                vaddq_s32(
                    vmull_s16(vneg_s16(t1.val[1]), end_tw.val[1]),
                    vmull_s16(t2.val[0], end_tw.val[1])))
            , 7);

        // reverse the end part
        end.val[0] = (int32x4_t)vrev64q_s32(end.val[0]);
        end.val[0] = vcombine_s32(vget_high_s32(end.val[0]), vget_low_s32(end.val[0]));
        end.val[1] = (int32x4_t)vrev64q_s32(end.val[1]);
        end.val[1] = vcombine_s32(vget_high_s32(end.val[1]), vget_low_s32(end.val[1]));

        // store the result
        vst2q_s32((int32_t *)fft_in+i, start);
        vst2q_s32((int32_t *)(fft_in+MDCT_M2-4-i/2), end);
    }

    // perform the FFT
    ne10_fft_c2c_1d_int32_neon(fft_out, fft_in, cfg, 0, 0);

    // post-twiddling
    for (int i = 0; i < MDCT_M2; i += 8)
    {
        // load the fft ouput and reverse the end part
        // fft_out_x.val[0] -> real part
        // fft_out_x.val[1] -> imaginary part
        int32x4x2_t fft_out_start = vld2q_s32((int32_t *)fft_out+i);
        int32x4x2_t fft_out_end = vld2q_s32((int32_t *)fft_out+MDCT_M-8-i);
        fft_out_end.val[0] = (int32x4_t)vrev64q_s32(fft_out_end.val[0]);
        fft_out_end.val[0] = vcombine_s32(vget_high_s32(fft_out_end.val[0]),
                                          vget_low_s32(fft_out_end.val[0]));
        fft_out_end.val[1] = (int32x4_t)vrev64q_s32(fft_out_end.val[1]);
        fft_out_end.val[1] = vcombine_s32(vget_high_s32(fft_out_end.val[1]),
                                          vget_low_s32(fft_out_end.val[1]));

        // load the twiddle factors
        // x_tw.val[0] -> cos twiddle
        // x_tw.val[1] -> sin twiddle
        int32x4x2_t start_tw = vld2q_s32(posttwiddle_start+i);
        int32x4x2_t end_tw = vld2q_s32(posttwiddle_end+i);

        int32x4x2_t spectrum_start;
        spectrum_start.val[0] = vshrq_n_s32(vaddq_s32(
            vqrdmulhq_s32(vnegq_s32(fft_out_start.val[0]), start_tw.val[0]),
            vqrdmulhq_s32(vnegq_s32(fft_out_start.val[1]), start_tw.val[1])), 8);
        spectrum_start.val[1] = vshrq_n_s32(vaddq_s32(
            vqrdmulhq_s32(vnegq_s32(fft_out_end.val[0]), end_tw.val[1]),
            vqrdmulhq_s32(fft_out_end.val[1], end_tw.val[0])), 8);

        int32x4x2_t spectrum_end;
        spectrum_end.val[0] = vshrq_n_s32(vaddq_s32(
            vqrdmulhq_s32(vnegq_s32(fft_out_end.val[0]), end_tw.val[0]),
            vqrdmulhq_s32(vnegq_s32(fft_out_end.val[1]), end_tw.val[1])), 8);
        spectrum_end.val[1] = vshrq_n_s32(vaddq_s32(
            vqrdmulhq_s32(vnegq_s32(fft_out_start.val[0]), start_tw.val[1]),
            vqrdmulhq_s32(fft_out_start.val[1], start_tw.val[0])), 8);

        spectrum_end.val[0] = (int32x4_t)vrev64q_s32(spectrum_end.val[0]);
        spectrum_end.val[0] = vcombine_s32(vget_high_s32(spectrum_end.val[0]),
                                           vget_low_s32(spectrum_end.val[0]));
        spectrum_end.val[1] = (int32x4_t)vrev64q_s32(spectrum_end.val[1]);
        spectrum_end.val[1] = vcombine_s32(vget_high_s32(spectrum_end.val[1]),
                                           vget_low_s32(spectrum_end.val[1]));

        // store the result
        vst2q_s32((int32_t *)spectrum+i, spectrum_start);
        vst2q_s32((int32_t *)(spectrum+MDCT_M-8-i), spectrum_end);
    }
}
\end{lstlisting}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 11 Analyse des résultats
    %   11.1 Validation des données
    %           - app:spectrum_comparison
    %               - app:spectrum_comparison_code
    %               - app:cmake_comp_mdct_float
    %               - app:cmake_comp_mdct_float_int
    %               - app:cmake_comp_mdct_i32_c
    %               - app:cmake_comp_mdct_i32_neon
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Validation des spectres de fréquences produits par les MDCT}\label{app:spectrum_comparison}
\subsection{Code source}\label{app:spectrum_comparison_code}
\paragraph{}
\lstset{language=C++}
\begin{lstlisting}
\end{lstlisting}

\subsection{Compilation}\label{app:spectrum_comparison_cmake}
\paragraph{}
\lstset{language=make}
\begin{lstlisting}
\end{lstlisting}





    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %   11.2 Gain en performance
    %       - app:perf_mdct_ne10
    %           - app:perf_mdct_ne10_code
    %           - app:perf_mdct_ne10_cmake
    %       - app:perf_mdct_fftw3
    %           - app:perf_mdct_fftw3_code
    %           - app:perf_mdct_fftw3_cmake
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Mesure des performances des MDCT \emph{Ne10} et MDCT de référence}\label{app:perf_mdct_ne10}
\subsection{Code source}\label{app:perf_mdct_ne10_code}
\paragraph{}
Code permettant de mesurer les performances des MDCT de \emph{Ne10} en \emph{float 32 plain C}, \emph{integer 32 plain C}, \emph{integer 32} avec optimisation NEON et de la MDCT de référence en \emph{double} (en fonction de la variable de préprocesseur définie à la compilation). Le code mesure et affiche le temps d'exécution moyen et l'écart type. Ces informations sont calculées sur un nombre d'exécutions donné en paramètre à l'exécutable. Les MDCT sont testées avec le même signal sinusoïdal en entrée dont la valeur par défaut est de \SI{200}{\hertz}.
\lstset{language=C++}
\begin{lstlisting}
#include <iostream>
#include <cstring>

#include "args_parser.h"
#include "mdct_constants.h"
#include "sin_wave.h"
#include "Timers.h"


#ifdef FIXED_POINT_C    // fixed point arithmetic

#include "ne10_mdct_i32_c.h"

#define INPUT_DATA              int16_t
#define OUTPUT_DATA             int32_t
#define GENERATE_SIN            sin_int
#define MDCT                    ne10_mdct_i32_c

#elif FIXED_POINT_NEON  // fixed point arithmetic

#include "ne10_mdct_i32_neon.h"

#define INPUT_DATA              int16_t
#define OUTPUT_DATA             int32_t
#define GENERATE_SIN            sin_int
#define MDCT                    ne10_mdct_i32_neon

#elif FLOATING_POINT    // floating point arithmetic

#include "ne10_mdct_f32_c.h"

#define INPUT_DATA              float
#define OUTPUT_DATA             float
#define GENERATE_SIN            sin_float
#define MDCT                    ne10_mdct_f32_c

#else                   // reference algorithm in floating point arithmetic

#include "ref_mdct.h"

#define INPUT_DATA              double
#define OUTPUT_DATA             double
#define GENERATE_SIN            sin_float

#endif


/**
 * @brief Run the MDCT on a single frame x times
 * the signal is a single tone configurable via the --sin parameter (200Hz by default)
 * the number of runs is setted by the --run parameter (1 by default)
 */
int main(int argc, char **argv)
{
    // initialize the parameters
    params p;
    try
    {
        p = parse_args(argc, argv);
    }
    catch(const std::runtime_error &err)
    {
        std::cerr << err.what() << std::endl;
        usage();
        return 1;
    }

    // print which MDCT will be tested
#ifdef FIXED_POINT_C
    std::cout << "MDCT Ne10 i32 plain C: "
        << p.runs << " runs with a single tone signal (" << p.frequency << "Hz)" << std::endl;
#elif FIXED_POINT_NEON
    std::cout << "MDCT Ne10 i32 Neon: "
        << p.runs << " runs with a single tone signal (" << p.frequency << "Hz)" << std::endl;
#elif FLOATING_POINT
    std::cout << "MDCT Ne10 f32 plain C: "
        << p.runs << " runs with a single tone signal (" << p.frequency << "Hz)" << std::endl;
#else
    std::cout << "Reference MDCT: "
        << p.runs << " runs with a single tone signal (" << p.frequency << "Hz)" << std::endl;
#endif

    // generate the time signal
    INPUT_DATA time_signal[MDCT_WINDOW_LEN]__attribute__((aligned(16)));
    memset(&time_signal, 0, MDCT_WINDOW_LEN*sizeof(INPUT_DATA));
    GENERATE_SIN(time_signal, MDCT_WINDOW_LEN, 0.9, p.frequency, 0.0, FS);

    // initialize an empty spectrum
    OUTPUT_DATA mdct_spectrum[MDCT_M]__attribute__((aligned(16)));
    memset(&mdct_spectrum, 0, MDCT_M*sizeof(OUTPUT_DATA));

    // perform the MDCT x times
    EvsHwLGPL::CTimers timer;
    int64_t *runtimes = static_cast<int64_t *>(malloc(p.runs * sizeof(int64_t)));

#ifdef REF
    for (unsigned i = 0; i < p.runs; ++i) {
        timer.Start();
        ref_float_mdct<INPUT_DATA>(time_signal, mdct_spectrum);
        timer.Stop();
        runtimes[i] = timer.GetTimeElapsed();
    }
\end{lstlisting}
\newpage
\begin{lstlisting}
#else
    MDCT ne10_mdct;
    for (unsigned i = 0; i < p.runs; ++i) {
        timer.Start();
        ne10_mdct.mdct(time_signal, mdct_spectrum);
        timer.Stop();
        runtimes[i] = timer.GetTimeElapsed();
    }
#endif

    // compute the average run time
    double avg = 0.0;
    for (unsigned i = 0; i < p.runs; ++i) avg += static_cast<double>(runtimes[i]);
    avg = avg / static_cast<double>(p.runs);
    std::cout << "average run time: " << avg << " ns" << std::endl;

    // compute the standard deviation
    double dev = 0.0;
    for (unsigned i = 0; i < p.runs; ++i) dev += static_cast<double>(runtimes[i]) - avg;
    dev = dev * dev / static_cast<double>(p.runs);
    dev = sqrt(dev);
    std::cout << "standard deviation: " << dev << std::endl;

    // clean
    free(runtimes);

    return 0;
}
\end{lstlisting}

\subsection{Compilation}\label{app:perf_mdct_ne10_cmake}
\paragraph{}
Commandes CMake pour la compilation des différents exécutables de tests de performance des MDCT :
\begin{itemize}
    \item la variable \texttt{FLOATING\_POINT} permet de compiler l'exécutable \texttt{run\_mdct\_f32\_c} pour tester la MDCT basée sur la FFT de \emph{Ne10} en \emph{float 32 plain C};
    \item la variable \texttt{FIXED\_POINT\_C} permet de compiler l'exécutable \texttt{run\_mdct\_i32\_c} pour tester la MDCT basée sur la FFT de \emph{Ne10} en \emph{integer 32 plain C};
    \item la variable \texttt{FIXED\_POINT\_NEON} permet de compiler l'exécutable \texttt{run\_mdct\_i32\_neon} pour tester la MDCT basée sur la FFT de \emph{Ne10} en \emph{integer 32} avec optimisations NEON;
    \item la variable \texttt{REF} permet de compiler l'exécutable \texttt{run\_mdct\_ref} pour tester la MDCT de référence en \emph{double};
\end{itemize}
\lstset{language=make}
\begin{lstlisting}
# Ne10 f32 x times on a single frame
add_executable(run_ne10_mdct_f32_c test/performance/run_ne10_mdct.cpp
    src/args_parser src/sin_wave.cpp src/Timers.cpp
    src/ne10_mdct_f32_c.cpp)
target_compile_definitions(run_ne10_mdct_f32_c PUBLIC -DFLOATING_POINT)
target_link_libraries(run_ne10_mdct_f32_c NE10)

# Ne10 i32 plain C x times on a single frame
add_executable(run_ne10_mdct_i32_c test/performance/run_ne10_mdct.cpp
    src/args_parser src/sin_wave.cpp src/Timers.cpp
    src/ne10_mdct_i32_c.cpp)
target_compile_definitions(run_ne10_mdct_i32_c PUBLIC -DFIXED_POINT_C)
target_link_libraries(run_ne10_mdct_i32_c NE10)

# Ne10 i32 neon x times on a single frame
add_executable(run_ne10_mdct_i32_neon test/performance/run_ne10_mdct.cpp
    src/args_parser src/sin_wave.cpp src/Timers.cpp
    src/ne10_mdct_i32_neon.cpp)
target_compile_definitions(run_ne10_mdct_i32_neon PUBLIC -DFIXED_POINT_NEON)
target_link_libraries(run_ne10_mdct_i32_neon NE10)

# Ref MDCT x times on a single frame
add_executable(run_ref_mdct test/performance/run_ne10_mdct.cpp
    src/args_parser src/sin_wave.cpp src/Timers.cpp
    src/ref_mdct.cpp)
target_compile_definitions(run_ref_mdct PUBLIC -DREF)
target_link_libraries(run_ref_mdct NE10)
\end{lstlisting}



\newpage
\section{Mesure des performances de la MDCT \emph{FFTW3} en \emph{float 32}}\label{app:perf_mdct_fftw3}
\subsection{Code source}\label{app:perf_mdct_fftw3_code}
\paragraph{}
Code permettant de mesurer les performances de la MDCT basée sur la FFT de \emph{FFTW3} en \emph{float 32}. Le code mesure et affiche le temps d'exécution moyen et l'écart type. Ces informations sont calculées sur \SI{10000000}{} d'exécutions. La MDCT est testée avec le même signal sinusoïdal en entrée dont la valeur est définie à \SI{440}{\hertz}.
\lstset{language=C++}
\begin{lstlisting}
#include <iostream>
#include <cstring>

#include "fftw3_mdct_f32.h"
#include "sin_wave.h"
#include "Timers.h"

#define RUNS        10000000
#define FREQUENCY   440.0

int main()
{
    // print which MDCT will be tested
    std::cout << "MDCT FFTW3 f32 plain C: "
        << RUNS << " runs with a single tone signal (" << FREQUENCY << "Hz)" << std::endl;

    // generate the time signal
    float time_signal[MDCT_WINDOW_LEN];
    sin_float(time_signal, MDCT_WINDOW_LEN, 0.9, FREQUENCY, 0.0, FS);

    // initialize an empty spectrum
    float spectrum[MDCT_M];
    memset(spectrum, 0, MDCT_M*sizeof(float));

    // initialize the configuration
    fftw3_mdct_f32 fftw3_mdct;

    // perform the MDCT
    EvsHwLGPL::CTimers timer;
    int64_t *runtimes = static_cast<int64_t *>(malloc(RUNS * sizeof(int64_t)));
    for (int i = 0; i < RUNS; ++i)
    {
        timer.Start();
        fftw3_mdct.mdct(time_signal, spectrum);
        timer.Stop();
        runtimes[i] = timer.GetTimeElapsed();
    }

    // compute the average run time
    double avg = 0.0;
    for (int i = 0; i < RUNS; ++i) avg += static_cast<double>(runtimes[i]);
    avg = avg / static_cast<double>(RUNS);
    std::cout << "average run time: " << avg << " ns" << std::endl;

    // compute the standard deviation
    double dev = 0.0;
    for (int i = 0; i < RUNS; ++i) dev += static_cast<double>(runtimes[i]) - avg;
    dev = dev * dev / static_cast<double>(RUNS);
    dev = sqrt(dev);
    std::cout << "standard deviation: " << dev << std::endl;

    // clean
    free(runtimes);

    return 0;
}
\end{lstlisting}

\subsection{Compilation}\label{app:perf_mdct_fftw3_cmake}
\paragraph{}
Commandes CMake pour la compilation de l'exécutable de tests de performance de la MDCT basée sur la FFT de \emph{FFTW3} en \emph{float 32}.
\lstset{language=make}
\begin{lstlisting}
# FFTW3 f32
add_executable(run_fftw3_mdct_f32 test/performance/run_fftw3_mdct_f32.cpp
    src/fftw3_mdct_f32.cpp src/sin_wave.cpp src/Timers.cpp)
target_link_libraries(run_fftw3_mdct_f32 fftw3f)
\end{lstlisting}







\end{document}