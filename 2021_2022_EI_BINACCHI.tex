\documentclass{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{moreverb}       % verbatim with tab

\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{hmargin=2.5cm}
\usepackage{amsmath}
\usepackage{siunitx}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{lscape}

% https://tug.org/FontCatalogue/libertinusserif/
%\usepackage{libertinus}
%\usepackage[T1]{fontenc}

\usepackage{libertine} % Police Linux Libertine en sérif, Linux Biolinum en sans-sérif.

\usepackage[libertine]{newtxmath} % Math avec la police Libertine
%\addtokomafont{disposition}{\normalfont\sffamily} % Police des titres (ajouter \normalfont pour enlever le bold)
%\addtokomafont{paragraph}{\bfseries} % Titre des paragraphes en gras
%\addtokomafont{subsubsection}{\bfseries} % Titre des subsubsections en gras
%\usepackage[scaled=.8]{beramono} % Police monospace

\usepackage{fancyhdr}       % en-têtes
\usepackage{lastpage}       % numéro de dernière page

\usepackage{appendix}       % annexes

% code
\usepackage{listings}

\usepackage{tocloft}

\newlistof{appendix}{tce}{Annexes}
\newcommand\asection[1]{%
    \addcontentsline{tce}{section}{\protect\makebox[1.3em][l]{\thesection}#1}}
\newcommand\asubsection[1]{%
    \addcontentsline{tce}{subsection}{\protect\makebox[2em][l]{\thesubsection}#1}}
%\renewcommand{\cfttcetitlefont}{\normalfont\Large\bfseries}



\title{Développement d'un codec audio AAC : optimisation de l'algorithme MDCT pour une architecture ARM}
\date{2020 -- 2021}
\author{Laura Binacchi}

\pagestyle{fancy}
\renewcommand\headrulewidth{1pt}
\fancyhead[L]{Laura Binacchi}
\fancyhead[C]{Développement d'un codec audio AAC}
\fancyhead[R]{2021 -- 2022}

\AtBeginDocument{
    \def\labelitemi{\textbullet}    % Redéfinition des puces dans les itemize
    \renewcommand{\times}{\text{×}} % Remplacer le gros «X» par un plus beau
    %\interfootnotelinepenalty=10000
}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}



\begin{document}
    \pagenumbering{gobble}
    \includepdf[pages={1}]{pdg}
    \newpage
    \tableofcontents
    \newpage
    \listoffigures
    \newpage
    \listofappendix

    \newpage
    \section*{Remerciements}
    % TODO

    \newpage
    \pagenumbering{arabic}  
    \section*{Introduction}
    \addcontentsline{toc}{section}{\protect\numberline{}Introduction}

    % Contexte du projet : serveur XT (XT VIA qui succède à ...) et passage d'une architecture Intel à une architecture ARM
    % Travail qui s'inscrit dans la continuité d'un travail théorique préalable
    % Optimisations possibles et choix de l'algorithme MDCT (mais on pourrait aussi faire la même chose pour le bloc quantization, etc.)
    % Optimisations du bloc MDCT mises en place : passage d'une arithmétique floating à fixed point et utilisation des fonctions SIMD qui offrent une meilleur capacité de calcul
    % Limite de l'optimisation : limite de temps (temps du stage) plutôt que gain de performance par rapport à ce qui est déjà en prod

    \paragraph{}
    Développement d'une solution de software embarqué sur processeur ARM pour encodage audio AAC optimisé aux applications d'EVS :
    \begin{itemize}
        \item Prise de connaissance de l'encodage AAC et de l'environnement EVS qui utilise ce type de format ;
        \item Prise de connaissance des résultats des optimisations possibles du modèle psycho-acoustique développé par EVS ;
        \item Développement du code en C ou Assembler pour l'encodage AAC sur plateforme ARM ;
        \item Test du système et documentation de son implémentation.s possibles du modèle psycho-acoustique développé par EVS ;
        \item Développement du code en C ou Assembler pour l'encodage AAC sur plateforme ARM ;
        \item Test du système et documentation de son implémentation.
    \end{itemize}

    \paragraph{}
    % sur base du cahier des charges, il a été décidé avec les personnes qui ont supervisé mon travail de me consacrer à l'optimisation du bloc MDCT

    \paragraph{}
    %Mon travail s'inscrit dans la continuité de celui de Wafaa Heddari, stagiaire qui m'a précédée au sein du département hardware-firmware d'EVS pour y travailler sur le codec AAC. Après une étude du codec AAC et des différents blocs qui le composent, son mémoire dégage des pistes d'amélioration des performances du codec AAC : like Removal of block switching, Fast MDCT, and Optimized TNS. And then test their implementation on C Code to compare the compilation speed between the original Codec and the optimized one\cite{Wafaa}.

    %L'amélioration des performances est nécessaire par la qualité grandissante des données audio et video -> de plus en plus grandes, et le besoin de maintenir plusieurs flux en tant réel dans le broadcast

    \paragraph{}
    Ce travail commencera par une présentation d'EVS et du département dans lequel s'est déroulé mon stage. Parmi les nombreux produits d'EVS, seul le serveur XT sera brièvement présenté puisque c'est spécifiquement pour ce dernier que le codec AAC est développé et optimisé.

    \paragraph{}
    Quelques notions théoriques indispensables à la compréhension du travail pratique seront ensuite développées avec une section consacrée au son et sa numérisation et une autre consacrée aux codecs MPEG, à leur fonctionnement et en particulier au fonctionnement du bloc MDCT de l'encodeur AAC.

    % But : garder la max de performance en perdant le moins en qualité


    %\paragraph{}
    %Si les sections de présentation des différentes itérations de la MDCT ont déjà permis de mettre en avant certains résultats en terme de performance ou de précision, c'est la section suivante qui présentera la protocole de valitation ainsi que les résultats obtenus pour la version finale de l'algorithme MDCT en \emph{integer}.

    \newpage
    \section{EVS Broadcast Equipment}
    \subsection{Présentation d'EVS et du département R\&D}
    \paragraph{}
    Mon stage s'est déroulé au sein de la société EVS Broadcast Equipment dont la figure \ref{fig:logo} représente le logo. EVS est une entreprise d'origine liégeoise devenue internationale. Fondée en 1994 par Pierre L'Hoest, Laurent Minguet et Michel Counson, EVS compte aujourd'hui plus de 600 employés dans plus de 20 bureaux à travers le monde mais son siège principal se situe toujours à Liège.

    \begin{figure}[H]
        \centering
        \includegraphics[width=.5\linewidth]{./images/EVS-logo.png}
        \caption{Logo de la société EVS Broadcast Equipment\cite{EVS:website}}
        \label{fig:logo}
    \end{figure}

    \paragraph{}
    EVS est devenu leader dans le monde du broadcast avec ses serveurs permettant l'accès et la diffusion instantanée des données audiovisuelles enregistrées sur ses serveurs. L'entreprise est également célèbre pour ses ralentis instantanés. Ces technologies sont utilisées pour la production live des plus importants événements sportifs dans le monde : le matériel EVS est notamment utilisé pour la retransmission des Jeux Olympiques depuis 1998.

    \paragraph{}
    Plus de 50\% des employés d'EVS travaillent en recherche et développement afin de répondre au marché du broadcast en constante évolution. Outre ses solutions techniques innovantes, EVS se différencie de ses concurrents par la proximité entretenue avec les clients en leur proposant des solutions à l'écoute de leurs besoins et en leur offrant un service de support de qualité.

    \paragraph{}
    C'est en R\&D, dans l'équipe Hardware-Firmware, que s'est déroulé mon stage. Sous la direction de Justin Mannesberg, cette équipe se compose d'une vingtaine d'employés spécialisés en développement embarqué et en développement FPGA. La situation particulière dans laquelle s'est déroulé mon stage, en pleine pandémie de Covid et alors que tous les employés étaient confinés, ne m'a pas permis d'interagir avec beaucoup de membres de l'équipe et ni de pouvoir observer leur travail. Bernard Thilmant (Software Engineer dans l'équipe Hardware-Firmare) a cependant réussi à m'apporter le soutien nécessaire à la bonne réalisation de mon stage : il m'a permis de m'initier au C++, m'a aidée à ne pas me perdre dans les concepts parfois complexes de l'encodage audio et m'a aidée à apporter la rigueur scientifique nécessaire à la réalisation de mon travail. J'ai également pu bénéficier de l'expertise technique de Frédéric Lefranc (Principal Embedded System Architect dans l'équipe Hardware-Firmare) ainsi que du suivi de Justin Mannesberg (Manager de l'équipe Hardware-Firmware).

    \subsection{Le serveur XT}
    \paragraph{}
    EVS développe et commercialise de nombreux produits allant des serveurs de production aux interfaces permettant d'exploiter des données audio-visuelles ou de monitorer des systèmes de production\cite{EVS:products}. Le serveur de production live XT est un des produits emblématiques d'EVS. Il permet de stocker de grandes quantités de données audio-visuelles et d'y accéder en temps réel afin de répondre aux besoins de la production en live. Par exemple, la remote LSM (\emph{Live Slow Motion} permet d'accéder aux contenus des serveurs XT afin de créer les ralentis pour lesquels EVS est célèbre dans le monde.

    \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.4\linewidth}
            \includegraphics[width=\linewidth]{./images/XT-VIA.png}
        \end{subfigure}
        \begin{subfigure}[b]{0.4\linewidth}
            \includegraphics[width=\linewidth]{./images/XT-VIA-ar.jpg}
        \end{subfigure}
        \caption{Vues avant et arrière (en configuration IP) de l'XT-VIA\cite{EVS:products}}
        \label{fig:xt-via}
    \end{figure}

    \paragraph{}
    Le serveur XT a connu plusieurs versions : XT, XT2, XT2+, XT3 et enfin l'XT-VIA. L'XT-VIA (cf figure \ref{fig:xt-via}), la plus récente version du serveur XT, en quelques informations clés\cite{EVS:products} :
    \begin{itemize}
        \item offre un espace de stockage de 18 à 54 TB, soit plus de 130h d'enregistrement en UHD-4K;
        \item dispose de 2 à plus de 16 canaux selon le format choisi : 2 canaux en UHD-8K (4320p), 6 canaux en UHD-4K (2160p) et plus de 16 canaux en FHD and HD (720p, 1080i, 1080p);
        \item permet une configuration hybride de ses entrées et sorties en IP (10G Ethernet SFP+, 100G en option, ST2022-6, ST2022-7, ST2022-8, ST2110, NMOS IS-04, IS-05, EMBER+, PTP) ou SDI (1.5G-SDI, 3G-SDI et 12G-SDI);
        \item supporte de nombreux formats d'encodage vidéo : UHD-4K (XAVC-Intra et DNxHR), HD/FHD (XAVC-I, AVC-I, DNxHD et ProRes), PROXY (MJPEG et H264);
        \item peut enregistrer 192 audio tracks non compressés et supporte les standards AES et MADI;
        \item offre de nombreuses possibilités de connection avec du matériel EVS ou non.
    \end{itemize}

    \paragraph{}
    C'est pour la dernière génération du serveur XT, l'XT-VIA, que le codec AAC est développé. La compression avec perte de données de ce codec permet d'optimiser l'espace occupé par les données audio sans en altérer la qualité perçue. Outre la qualité audio, les performances de l'encodage sont importantes à prendre en compte pour permettre l'enregistrement de plusieurs canaux en parallèle tout en conservant un traitement de l'information qui tienne le temps réel. L'optimisation des performances doit tenir compte de l'architecture de l'XT-VIA : l'architecture ARM Neon remplace l'architecture Intel x86 de ses prédécesseurs avec des différences importantes dans les fonctions intrinsèques.


    \newpage
    \section{L'encodage audionumérique : généralités}
    \subsection{Le son}
    % onde acoustique -> 

    % - son audible = vibration entre 20 et 20kHz

    % le signal, analogique (continu) ou discret, peut avoir une représentation :
    % - temporelle
    % - fréquentielle
    % exemple de signaux périodiques (sinus, carré, etc) -> pp 6-7 + truc interactif

    % - spectre d'amplitude (utile) et spectre de phase (pas utile)

    % - toute fonction p(x, t) peut être exprimée par une somme de fonctions (co-)sinusoidales : formule pour les fonctions périodiques + transformée de Fourier pour les fonctions n'est pas périodique dans le temps

    \subsection{La numérisation d'un signal}
    \label{audionumerique}
    % transformation de fourier :
    % https://www.claudegabriel.be/Math%C3%A9matiques%20appliqu%C3%A9es,%20chapitre%204.pdf -> p12 sur N pair / impair
    % à la base -> signaux périodique (faire bref)
    % -> ce qui nous intéresse : transformation pour signal non périodique discret -> DCT


    \newpage
    \section{Les codecs audio}
    \subsection{Définition d'un codec}
    \paragraph{}
    Un codec est un procédé logiciel composé d'un encodeur (\emph{\textbf{co}der}) et d'un décodeur (\emph{\textbf{dec}oder})\cite{wiki:codec}. Un codec audio permet donc, d'une part, de coder un signal audio dans un flux de donnée numériques et, d'autre part, de décoder ces données afin de restituer le signal audio.

    \paragraph{}
    Les codecs sont dits avec perte (\emph{lossy}) ou sans perte (\emph{lossless}). Le PCM est par exemple un codec sans perte puisqu'il encode la totalité des informations sonores dans la bande de fréquences humainement audible. Ce type de codec permet de conserver la qualité de l'audio mais nécessite en contrepartie un espace de stockage conséquent, même avec une compression des données.

    \paragraph{}
    Afin de réduire l'espace de stockage nécessaire, les codecs avec perte permettent de supprimer une partie des données audio. C'est le cas des codecs définis par les normes MPEG dont fait partie le codec AAC.

    \subsection{Les codecs MPEG}
    \paragraph{}
    MPEG (\emph{Moving Picture Experts Group}) désigne une alliance de différents groupes de travail définissant des normes d'encodage, de compression et décompression et de transmission de média audio, vidéo et graphiques\cite{wiki:MPEG}. Le groupe est actif depuis 1988 et a produit depuis de nombreuses normes.

    \paragraph{}
    Les codecs audio qui implémentent les normes MPEG ont pour point commun d'être des codecs avec perte de données basés sur un modèle psychoacoustique. Le premier est le MP3, défini par la norme MPEG-1 Layer-3 ISO/IEC 11172-3:1993. Le codec AAC est conçu en 1997 pour remplacer le MP3. Il est défini par les normes MPEG-2 partie 7 ISO/IEC 13818-7:2006\cite{ISO13818-7} et MPEG-4 partie 3 ISO/IEC 14496-3:2019\cite{ISO14496-3}.

    \paragraph{}
    Les normes MPEG définissent les grandes lignes de l'encodage et du décodage et le format du conteneur mais pas l'implémentation du codec qui peut de ce fait être plus ou moins performant. Les codecs MPEG sont typiquement composés des blocs suivants :
    \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{.6\linewidth}
            \includegraphics[width=\linewidth]{./images/1999-Brandenburg-simple-AAC-encoder.png}
            \caption{Schéma fonctionnel de l'encodeur}
        \end{subfigure}
        \begin{subfigure}[b]{.6\linewidth}
            \includegraphics[width=\linewidth]{./images/1999-Brandenburg-simple-AAC-decoder.png}
            \caption{Schéma fonctionnel du décodeur}
        \end{subfigure}
        \caption{Vue simplifiée d'un codec MPEG basé sur un modèle psychoacoustique\cite{1999-Brandenburg}}
    \end{figure}
    \paragraph{}
    L'encodeur est composé des blocs suivants :
    \begin{description}
        \item[filter bank] la banque de filtres décompose le signal temporel d'entrée en différentes composantes fréquentielles
        \item[perceptual model] le modèle psychoacoustique utilise le signal temporel et/ou sa décomposition fréquentielle pour éliminer les données audio dont l'absence ne nuira pas à la qualité perçue à l'écoute ()
        \item[quantization and coding] la quantification attribue une valeur numérique aux données du spectre de fréquences : elle sont typiquement codées avec une méthode entropique qui peut être optimisée avec le modèle psychoacoustique
        \item[encoding of bitstream] les données sont formatées en un flux contenant typiquement le spectre de fréquences codé et des informations supplémentaires permettant l'encodage
    \end{description}
    
    \paragraph{}
    Le décodeur a un fonctionnement inverse : le flux de données est décodé (\textbf{decoding of bitstream}), les composantes fréquentielles du signal sont retrouvées par l'opération inverse à la quantification (\textbf{inverse quantization}) et ces sous-bandes fréquentielles sont finalement rassemblées pour reconstituer le signal temporel (\textbf{synthesis filter bank}).

    \paragraph{}
    Le fonctionnement du décodeur ne sera pas plus développé dans ce travail car le bloc MDCT fait partie de la banque de filtres de l'encodeur. Le fonctionnement spécifique de l'encodeur AAC sera par contre détaillé dans la section \ref{sec:AAC}.


    \subsection{Les modèles psychoacoustiques}
    \paragraph{}
    Le section précédente a défini les codecs MPEG comme étant basés sur un modèle psychoacoustique. La psychoacoustique est une branche de la psychophysique qui étudie la manière dont l'oreille humaine perçoit le son\cite{wiki:psychoacoustic}. Cette discipline permet d'améliorer la compression d'un signal audio en éliminant les sons qui sont captés par un microphone mais qui ne peuvent pas être perçus par l'oreille humaine et les avancées dans cette discipline permettent de développer des encodeurs audio de plus en plus performants. Les codecs basés sur un modèle psychoacoustique sont toujours des codecs avec perte puisqu'une partie des informations auditives sera définitivement perdue, ce qui ne nuit pour autant pas à la qualité perçue du son.

    \paragraph{}
    L'encodage audionumérique tient déjà compte des seuils de fréquences humainement audibles pour limiter les données audio enregistrées : nous l'avons vu dans la section \ref{audionumerique}, aucun son n'est perçu en-deça de 20Hz ou au-delà de 20kHz. La psychoacoustique permet de mieux dessiner limite entre ce qui est humainement audible ou non afin d'éliminer un maximum des informations non pertinentes et ainsi augmenter le facteur de compression des données : le facteur de compression des codecs MPEG est environ 15 fois supérieur à celui du CD\cite{2019-Herre-Dick}.

    \paragraph{}
    Les effets de masque sont au centre des différents modèles psychoacoustiques utilisés pour la compression audio. L'enjeu afin d'obtenir le meilleur taux de compression est de calculer le plus finement possible les seuils de masquage, i.e. la limite entre les informations pertinentes et celles qui peuvent être éliminées. Les effets de masques dans le domaine fréquentiel (\emph{spectral masking effects}) sont parmi les plus utilisés mais il en existe d'autres, e.g. dans le domaine temporel. La figure suivante représente différents effets de masque du domaine fréquentiel :
    \begin{figure}[H]
        \centering
        \includegraphics[width=.6\linewidth]{./images/2019-Herre-Dick-masking-effect.png}
        \caption{Effets de masque dans le domaine fréquentiel\cite{2019-Herre-Dick}}
    \end{figure}

    \paragraph{}
    Les lignes représentent le seuil 
    \begin{description}
        \item[Threshold in quiet] la ligne en pointillé représente le seuil d'audibilité dans le calme, indépendamment de tout autre élément qui pourrait interférer
        \item[Masking threshold] 
    \end{description}


    % SPL) A frequency dependent threshold of in hearing in quiet describes the minimum sound pressure level of a sound to be perceivable isolation and under extremely quite conditions. (SPL) of a sound be perceivable in isolation and curve under extremely conditions. • In the presence of to a masker, the threshold in quiet changes into quite a masking threshold, which bell-shaped increase the in frequencies the vicinity of the masker, depending on its • shows In the a presence of a masker, threshold in in quiet curve changes into a masking threshold, frequency, level, and signal increase type. Any sound beneath threshold is masked by the louder which shows a bell-shaped in frequencies in the this vicinity of the masker, depending on its signal, and level, thus and inaudible the Any average perceptual coding, the louder coding signal, error frequency, signal for type. sound listener. beneath In this threshold audio is masked by the (i.e., the introduced quantization noise) corresponds to the probe signal in this experimental and thus inaudible for the average listener. In perceptual audio coding, the coding error (i.e., scenario. the introduced quantization noise) corresponds to the probe signal in this experimental scenario. • Masking effects are are strongest strongest signals are within the critical bandwidth of the masker. • Masking effects for for signals that that are within the critical bandwidth of the masker. Within Within the critical bandwidth, the masking threshold remains constant. Furthermore, the the critical bandwidth, the masking threshold remains constant. Furthermore, the masking effects masking spread to frequencies the (so-called critical bandwidth (so-called The inter-band spread to effects frequencies beyond the critical beyond bandwidth inter-band masking). upper masking). The upper slope of the masking threshold depends on multiple factors, such as absolute slope of the masking threshold depends on multiple factors, such as absolute frequency and sound frequency and of sound pressure whereas level of the the lower masker, whereas lower slope dependency. hardly shows a level pressure level the masker, slope hardly the shows a level dependency. • Depending on the type of masker, i.e., tone or (narrow-band) noise, the strength of the masking • Depending the type of masker, i.e., can tone or (narrow-band) the strength of the masking effect varies. on While noise-like maskers mask tone-like signals noise, very well (up to a masker-to-probe effect varies. maskers can mask tone-like signals very well (up to a masker-to- level ratio of While about noise-like 6 dB), tone-like maskers can mask noise only to a much weaker extent [29] probe level ratio of about 6 dB), tone-like maskers can mask noise only to a much weaker extent (about 20 dB). [29] (about 20 dB).      \paragraph{}     Le calcul des   


    
    
    
    Le calcul du seuil de masquage tient compte\cite{2019-Herre-Dick} :
    \begin{itemize}
        \item des effets de masquage monophonique de la perception non-linéaire des fréquences, plus fine pour les basses fréquences;
        \item des effets de masque dans le temps;
        \item de l'effet de masque dans une bande de fréquence ou entre bandes de fréquences;
        \item l'impact de la tonalité sur le masquage
        \item masking over time
    \end{itemize}


    \newpage
    \section{Le codec AAC}
    \label{sec:AAC}
    \subsection{Fonctionnement de l'encodeur AAC}
    % présentation des différents blocs
    % \cite{wiki:AAC}

    %In this thesis, we are going to study the different blocks of an AAC encoder based on the standard ISO/IEC 13818-7 such as the psychoacoustic model, Gain control, Transform block, Spectral processing, Quantization and Entropy coding. \cite{Wafaa}

    % Les codecs définis par les normes MPEG sont basés sur le modèle psychoacoustiquev
    % Les performances des codecs audio définis par les normes MPEG sont rendues possibles par les recherches en psychoacoustique.


    %AAC supports inclusion of 48 full-bandwidth (up to 96 kHz) audio channels in one stream plus 16 low frequency effects (LFE, limited to 120 Hz) channels, up to 16 "coupling" or dialog channels, and up to 16 data streams. The quality for stereo is satisfactory to modest requirements at 96 kbit/s in joint stereo mode; however, hi-fi transparency demands data rates of at least 128 kbit/s (VBR). Tests[which?] of MPEG-4 audio have shown that AAC meets the requirements referred to as "transparent" for the ITU at 128 kbit/s for stereo, and 320 kbit/s for 5.1 audio.[citation needed] 
    % AAC uses only a modified discrete cosine transform (MDCT) algorithm, giving it higher compression efficiency than MP3, which uses a hybrid coding algorithm that is part MDCT and part FFT.[4]


    \paragraph{}
    Le codec AAC (Advanced Audio coding) est définit  , défini par la norme . Les recherches en psychoacoustique ont permis de développer un algorithme d'encodage plus performant pour l'AAC que pour le MP3 : il permet d'encoder moins données audio tout en gardant la même qualité perçue au décodage\cite{1999-Brandenburg}.



    \subsection{Le bloc MDCT}
    % \begin{itemize}
    %     \item particularités par rapport à la FFT
    %     \item basée sur la DCT-IV
    %     \item niveaux de complexité (O...)
    % \end{itemize}


    \newpage
    \section{Environnement de développement}
    \paragraph{}
    Platformes : passage de Intel à ARM nécessaire à cause de la lib Ne10 et impossibilité de maintenir une version de référence Intel

    \paragraph{}
    Développement remote sur RPI + photo raspberry

    \paragraph{}
    CentOS7 parce que utilisé sur tout le matériel linux EVS

    \paragraph{}
    Projet en C++ mais qui ressemble fort à du C car implémentation d'un codec -> améliorations possibles : juste du C ?

    \paragraph{}
    Le build du projet se fait grâce à un fichier CMake à la racine du projet. Ce fichier présenté dans l'annexe \ref{an:cmake_super} permet d'appeler les CMake du projet \emph{audio\_encoding} (projet contenant les MDCT et ses tests) et de la librairie \emph{Ne10}. Contrairement à l'usage, ces deux projets sont construits par défaut en mode \emph{release} et non en mode \emph{debug} afin de ne pas risquer de faire tourner les tests de performance en mode \emph{debug}. Les commandes du CMake générant les exécutables de tests seront fournies en annexe à la suite du code source de ces tests.

    \newpage
    \section{Algorithmes MDCT de référence}
    \paragraph{}
    La première étape de ce travail consiste à développer des algorithmes de référence afin de valider les différentes MDCT implémentées par la suite. Ces algorithmes de référence sont développés en algorithmique flottante sur base de la formule mathématique de la MDCT. Ils permettent de générer des spectres de fréquence en \emph{float} ou en \emph{integer} afin de valider les données de sortir des MDCT optimisées.

    \subsection{Description mathématique}
    \label{sec:desc-math}
    \paragraph{}
    La transformation effectuée par la MDCT est donnée par l'équation suivante\cite{wiki:MDCT} :
    $$X_k = \frac{2}{\sqrt{2N}} \sum_{n=0}^{2N-1} x_n \cos \left[ \frac{\pi}{N} \left( N + \frac{1}{2} + \frac{N}{2} \right) \left( k + \frac{1}{2} \right) \right]$$
    \begin{description}
        \item[$X_k$] avec $k \in [0, N[$ pour une fenêtre d'entrée de 2N échantillons
        \item[$x_n$] avec $n \in [0, 2N[$ : la fenêtre d'entrée
        \item[$F: R^{2N} \rightarrow R^N$] la MDCT est une fonction linaire qui pour 2N nombres réels d'entrée produit N nombre réels en sortie
    \end{description}

    \paragraph{}
    La MDCT a été implémentée avec une fenêtre d'entrée de $2N = 1024$ échantillons. Le bloc de sortie, i.e. le spectre de fréquences de la fenêtre d'entrée, aura donc une taille de 512. Ces valeurs, utilisées à de très nombreux endroits du code, sont rassemblées dans le header \texttt{mdct\_constants.h} présenté dans l'annexe \ref{an:mdct_const}. Ce fichier contient également d'autres valeurs précalculée sur base de la taille de la fenêtre d'entrée.

    \paragraph{}
    La section suivante présente deux implémentations simples de cette formule. Ces implémentations ne pourraient pas être utilisées sans avoir été optimisées car elles seraient beaucoup trop lentes pour un codec qui doit tenir le temps réel. La complexité d'une implémentation de cette formule est de $O(N^2)$ opérations (où N est la taille de la fenêtre d'entrée). Cette complexité peut être ramenée à $O(N \log N)$ opérations par une factorisation récursive. La complexité peut également être diminuée en se basant sur une autre transformation, e.g. une DFT (\emph{Discrete Fourier Transorm}) ou une autre DCT (\emph{Discrete Cosine Transform}) : la complexité sera alors de $O(N)$ opérations de pré et post processing en plus de la complexité de la DFT ou de la DCT choisie\cite{wiki:MDCT}. C'est cette dernière option qui a été retenue pour ce travail.

    \subsection{Implémentations des MDCT de référence en \emph{floating point} et \emph{fixed point}}
    \paragraph{}
    La formule mathématique de la MDCT a été implémentée très simplement en algorithmique flottante avec la possibilité d'obtenir le spectre de fréquences codés en \emph{float}, \emph{double} ou \emph{int32} depuis une fenêtre d'entrée en \emph{int16}. L'objectif de cet implémentation est de pouvoir vérifier les données des implémentations optimisées de la MDCT et de mesurer leur précision.

    \paragraph{}
    La première implémentation de l'équation de la MDCT est présentée dans l'annexe \ref{an:ref_mdct_float}. La fonction développée permet de faire ses calculs et d'obtenir un résultat aussi bien en \emph{float}) (32 bits) qu'en \emph{double} (64 bits) grâce à l'utilisation d'un \emph{template}.

    \paragraph{}
    La seconde fonction de référence est présentée dans l'annexe \ref{an:ref_mdct_int}. Elle permettra de vérifier les résultats des implémentations optimisées en \emph{fixed point}. Tous les calculs ne sont pas fait en algorithmique entière : la fonction fait les mêmes calculs que la fonction de référence en algorithmique flottante (uniquement en \emph{double} cette fois garder le plus de précision possible) et cast le résultat final dans un integer de 32 bits qui correspond à une notation Qx.15 signée.

    \subsection{Validation des algorithmes de référence}

    \paragraph{}% TODO
    Validation avec un code d'exemple qui correspond à un signal sinusoidal (single tone) -> annexes : génération d'un signal single tone \ref{an:sin_wave_int}+ code qui sort les données. Code pas ici mais renvoi à la section sur la validation des données -> pour le float, on regarde ce qui sort, pour le integer, on vérifie avec calcul q15


    \paragraph{}% TODO
    Présentation des résultats sous forme de données brutes ou de graphique.

    \paragraph{}% TODO
    Explication de la lecture des résultats, calcul des bandes de fréquences représentées. Mise en évidence qu'on a bien une seule composante fréquentielle comme attendu pour un signal single tone

    % \begin{itemize}
    %     \item sortie des données et générations de graphiques avec gnuplot
    %     \item résolution en fréquence pour une fenetre de 1024 samples pour un signal échantillonné à 48kHz : sur les graphiques $\frac{48000}{1024} = \SI{46.875}{\hertz}$ 1.3333... ms -> f = 1 / 1.33333 = 750 Hz OU res = fs / samples -> sur les graphiques on a des raies de fréquence de 750 Hz. Pour une fenêtre de 1024 = Hz
    % \end{itemize}
    % Graphiques sur sinusoide simple : augmenter la fréquence (i * qch pour déplacer la bande de fréquence), 

    \paragraph{}% TODO
    + les résultats auraient été plus précis avec la fonction de fenêtre -> voir améliorations possibles


    \newpage
    \section{Algorithme MDCT basé sur la FFT}
    \subsection{Optimisations attentues}
    % algo qui vient du code d'exemple dsprelated, basé sur la FFT
%    \url{https://infoscience.epfl.ch/record/59946}
%    \url{https://www.cis.rit.edu/class/simg716/Gauss_History_FFT.pdf}
%    \url{https://sci-hub.se/https://www.jstor.org/stable/29775194#}

    %jouer sur la symétrie pour ne calculer que la moitié

    % \subsection{Code DSP related}
    % Code qui se base sur une FFT avec opérations de pre et de post twiddle
    % Annexes : code de la MDCT, test et procédure d'installation de la librairie FFTW

    % au code de base, il faut aussi ajouter la fonction de fenêtre (MLT) qui n'était pas présente.
    \paragraph{}
    Choix de l'optimisation de la MDCT basé sur sur une DCT : la FFT -> complexité de O (N log N) (N taille de la fenetre) + O(N) opérations de pré et de post processing.

    \paragraph{}
    But : utiliser une FFT déjà optimisée pour n'avoir à optimiser "que" les opérations de pré et de post processing
    Exemple trouvé sur le site DSP related -> Annexe ? Citation ?

    \subsection{Implémentation de la MDCT basée sur la FFT de la librairie FFTW3}
    \paragraph{}
    Code développé à partir de cet exemple en annexe. Il est basé sur la librairie FFTW3 qu'on ne peut pas garder car ne permet pas de travailler en integer -> sera amené à être retravaillé.

    \paragraph{}
    Explications des paramètres du code :
    \begin{itemize}
        \item fenêtre de 1024
        \item pre-twiddle -> 256
        \item FFT => FFT avec une fenêtre d'entrée réduite et donc une complexité réduite
        \item post-twiddle -> 512
    \end{itemize}

    % \subsection{Réduction de la fenêtre d'entrée}
    % (pre et post processing/twiddles pour faire moins de FFT) -> réduction de la fenêtre de la FFT

    \subsection{Validation}
    \paragraph{}
    Validé avec un single tone signal + l'algo de référence.

    \paragraph{}
    Code d'exemple qui teste l'algo de référence et l'algo FFTW3 avec les mêmes données d'entrée pour comparaison. (on fait la différence pour la précision ? ce n'est peut être pas pertinent de la faire déjà)

    \paragraph{}
    Présentation des résultats sous forme de données brutes ou de graphiques.

    A ce niveau, pour valider, j'ai aussi essayé de faire la IMDCT mais dû à l'overlap, sur une seule fenetre, on ne sait pas reconstruire le signal -> pas possible de valider comme ça


    \newpage
    \section{Intégration de la librairie \emph{Ne10}}
    \subsection{Choix de la librairie}
    \paragraph{}
    La librairie \emph{FFTW3} utilisée pour l'itération précédente de la MDCT ne propose pas de FFT en algorithmique entière. Le passage à une autre librairie était donc nécessaire et le choix s'est porté sur la librairie \emph{Ne10} qui propose différentes FFT en \emph{fixed point}.

    \paragraph{}
    Le projet \emph{Ne10} propose toute une série de fonctions mathématiques et physiques de base ainsi que des fonctions de traitement de signal et de traitement d'image. La librairie est spécifiquement développée pour les architectures ARM possédant les opérations SIMD Neon (ARMv7 et ARMv8-A)\cite{Ne10}.

    \paragraph{}
    \emph{Ne10} propose à la fois des fonctions développées en \emph{plain C} et des fonctions optimisées avec les instructions SIMD Neon : les deux types de fonctions seront utilisées pour développer une MDCT optimisée et pour conserver une MDCT de référence en \emph{plain C}. Maintenir une MDCT \emph{plain C} permettra d'avoir une référence pour la mesure des performances de l'algorithme \emph{fixed point} mais pourrait aussi s'avérer utile pour une utilisation de l'encodeur AAC sur une architecture ARM ne possédant pas les instructions Neon.

    \paragraph{}
    L'utilisation de la librairie \emph{Ne10} est soumise à la licence \emph{3-Clause BSD}, license permissive qui permet un usage commercial des produits intégrant la librairie et qui ne contraint pas à en distribuer le code source\cite{BSD}.

    \subsection{Implémentation de la MDCT basée sur la FFT \emph{Ne10} en \emph{float 32}}
    \paragraph{}
    La librairie \emph{Ne10} s'installe simplement en suivant les instructions données par la documentation : clone du projet GitHub, run du CMake et build du projet\cite{Ne10}. La librairie ne peut cependant être installée que sur une plateforme Linux, Android ou iOS reposant sur une architecture ARM. À partir de ce moment, il n'est donc plus possible de maintenir une implémentation de référence de la MDCT pour une architecture Intel.

    \paragraph{}
    \emph{Ne10} propose des algorithmes de FFT \emph{real to complex} et \emph{complex to complex} en \emph{floating point} (32 bits) ou en \emph{integer} (32 bits et 16 bits). L'objectif est évidemment de passer toute la MDCT en \emph{integer} mais pour un premier test de la librairie, l'algorithme de la section précédente a tout d'abord été repris en remplaçant la FFT de \emph{FFTW3} par la fonction \texttt{ne10\_fft\_c2c\_1d\_float32\_neon} de \emph{Ne10} : FFT en \emph{complex to complex} en \emph{float 32}, i.e. l'entrée et la sortie de la FFT sont représentées sous forme de tableaux de nombres complexes codés en \emph{float} sur 32 bits.

    \paragraph{}
    L'annexe \ref{an:mdct_ne10_f32} présente le code de cette implémentation. L'annexe \ref{an:mdct_ne10_f32_header} montre que ce code est construit sur le même modèle que le code utilisant la librairie \emph{FFTW3}. La classe contient la configuration de la FFT et les tableaux contenant les données d'entrée, les données de sortie et les facteurs de twiddling. La classe définit trois fonctions publiques : le constructeur, le destructeur et la fonction MDCT.

    \paragraph{}
    L'annexe \ref{an:mdct_ne10_f32_constructor} montre l'initialisation de la MDCT dans le constructeur de la classe. Le constructeur initialise les tableau de facteurs de twiddling de le même manière que l'algorithme basé sur la FFT de \emph{FFTW3}. La configuration de la FFT de \emph{Ne10} se fait conformément au code d'exemple donné par la documentation de la librairie\cite{Ne10} avec en paramètre la taille de la FFT qui correspond au quart de la taille de la fenêtre d'entrée.

    \paragraph{}
    Le destructeur présenté à l'annexe \ref{an:mdct_ne10_f32_destructor} permet de libérer la mémoire allouée pour la FFT en appelant la fonction adéquate de la librairie \emph{Ne10}.

    \paragraph{}
    La fonction MDCT présentée dans l'annexe \ref{an:mdct_ne10_f32_func}, comme pour l'algorithme précédent :
    \begin{itemize}
        \item effectue les opérations de pre-processing ou pre-twiddling : ce sont les mêmes que celle de la MDCT \emph{FFTW3} en arithmétique \emph{floating point} sur 32 bits;
        \item appelle l'algorithme de FFT : la FFT de \emph{Ne10} prend en paramètres les tableaux contenant les données d'entrée et de sortie, la configuration de la FFT et un \emph{integer} à \texttt{0} pour réaliser la FFT ou à \texttt{1} pour réaliser l'opération inverse;
        \item effectue les opérations de post-processing ou post-twiddling : ici aussi les mêmes que celles de la MDCT \emph{FFTW3} en arithmétique \emph{floating point} sur 32 bits.
    \end{itemize}

    \paragraph{}
    L'algorithme développé ici ne diffère donc pas de l'algorithme présenté à la section précédente. Son développement est trivial mais il permet de tester et de valider le fonctionnement de la librairie \emph{Ne10}.

    \subsection{Validation}
    \paragraph{}
    L'utilisation de la librairie \emph{Ne10} est validée par comparaison du spectre de fréquence qu'elle génère avec les spectres générés par la MDCT de référence en \emph{double} et par la MDCT basée sur \emph{FFTW3} également en \emph{double}. Les MDCT sont appelée en \emph{double} pour plus de précision. La comparaison aurait pu se faire sur base de tous les algorithmes de MDCT en \emph{float} sur 32 bits mais le choix qui a été fait ici permet en plus de vérifier que la perte de précision entre le \emph{float} et le \emph{double} soit acceptable.

    \paragraph{}
    Le code source permettant de comparer les trois MDCT en \emph{floating point} est présenté à l'annexe \ref{an:valid_comp_source}. Il sera expliqué en détail dans la section \ref{sec:validation} consacrée à la validation des données des MDCT. Compilé avec les commandes CMake de l'annexe \ref{an:valid_comp_float}, le code produit un exécutable permettant de comparer les spectres de fréquence produits par les trois MDCT \emph{floating point} en les affichant en console.

    \begin{figure}[H]
        \centering
        \includegraphics[width=.1\linewidth]{./images/TODO.png}
        \caption{}
        \label{fig:comp_mdct_float}
    \end{figure}

    \paragraph{}
    En redirigeant les données sorties en console vers un fichier texte, il est possible d'exploiter ces données sous forme de graphique. (voir figure \ref{fig:comp_mdct_float}) TODO : explication du graphique

    \paragraph{}
    TODO : présentation de la précision

    \subsection{Performances}
    Une fois l'utilisation de la librairie \emph{Ne10} validée,  Mesure de la différence de performance entre différentes FFT : code en annexe



    \section{Algorithme MDCT en arithmétique fixed point}
    \label{sec:fixed_point}
    \subsection{Arithmétique fixed point}
    \paragraph{}
    trivial en float (reprendre le code de dsp) mais pour l'implémentation en arithmétique entière, attention à mettre dans les bonnes ranges

    La notation \emph{fixed point} peut se faire 

    % \paragraph{Points d'attention}
    % \begin{itemize}
    %     \item les dépassements : 16 bits + 32 bits -> potentiellement 33 bits, 16*16 -> 32, etc. à voir en fonction des valeurs réelles
    %     \item alignement des tableaux (souvent c'est une contrainte imposée car permet facilement d'optimiser du code) : résolutions possibles en allouant dynamiquement les tableaux et en jouant avec une arithmétique de pointeur OU utilisation de posix mem align...
    % \end{itemize}

    % Attention à la manière d'écrire le code. Ici on n'a pas besoin de faire attention à ce que le compilateur puisse faire du inline (ex remplacer l'appel à z = add(a, d) par z = a+d pour économiser le call) car l'algo est déjà très optimisé -> pas d'optimisations de compilateur possible et en plus on a une grosse routine -> économiser un call n'est pas forcément intéressant.

    \subsection{Améliorations attendues}
    \paragraph{}
    Le code de DSP related est en floating point -> passage en fixed point : opérations sur des entiers plus performantes + meilleure intégration (éviter le passage artificiel de l'entier au flottant et inversement)
    % Sur le format Qx.y :
    % https://www.pathpartnertech.com/representing-decimal-data-in-q-format/
    % https://www.allaboutcircuits.com/technical-articles/fixed-point-representation-the-q-format-and-addition-examples/
    % https://en.wikipedia.org/wiki/Q_(number_format)
    % et surtout https://web.archive.org/web/20171104111827/http://www.superkits.net/whitepapers/Fixed%20Point%20Representation%20%26%20Fractional%20Math.pdf

    % Intérêt de passer un integer: même si on ne gagne que 5\% de performance, on gagne du temps avant (les données qu'on reçoit sont en int16 -> pas de conversion vers le float après) et après (la quantification notament sera probablement plus rapide en integer)

    % Test de performance : il faut qu'à la fin l'implementation fixed point soit au moins aussi rapide que floating point


    \subsection{Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique \emph{fixed point}}
    \paragraph{}
    L'annexe \ref{an:mdct_ne10_i32_c} présente l'implémentation de la MDCT \emph{Ne10 fixed point} en \emph{plain C}. La classe \texttt{mdct\_ne10\_i32\_c} a la même structure que l'itération précédente de la MDCT. Le header présenté dans l'annexe \ref{an:mdct_ne10_i32_c_header} montre que seul le type de certaines données a changé :
    \begin{itemize}
        \item Le tableau de facteurs de \emph{twiddling} passe du \texttt{float} au \texttt{int16\_t};
        \item La fonction MDCT prend en paramètres un signal temporel en \texttt{int16\_t} et renvoie un spectre en \texttt{int32\_t} au lieu des tableaux de \texttt{float}.
    \end{itemize}

    \paragraph{}
    Le passage de la FFT en \emph{}


    \paragraph{}
    Explication du code en annexe en accord avec les explications de la première subsection sur le fixed point

    \subsection{Performances}
    \paragraph{}
    Explication du code en annexe qui permet de mesurer les performances (avec code Timer)
    performances de la FFT FFTW3 en f32 pour comparaison :average run time:   4259.95 ns
    standard deviation: 2.07873e-06 ns


    \paragraph{}
    Démonstration des résultats

    \paragraph{}
    Explication des résultats pas attendus : à ce niveau, résultats pas intéressants car + d'opérations qu'en flottant et ARM a des fonctions d'algo flottante

    \paragraph{}
    Pour soutenir cette hypothèse :  Test de la librairie et des performances des différentes FFT : performances équivalentes en 32 bits (floating ou fixed) et deux fois plus rapides en 16 bits


    Pour comparaison, le temps d'exécution de la FFT de la librairie \emph{FFTW3} a également été mesuré, en \emph{float 32} puisque la FFT de \emph{Ne10} est en \emph{float 32}. Le code de la 

    Pendant mon stage, j'ai aussi essayé l'algo en Q15 mais échec à cause du manque de documentation des fonctions (quelle headroom prévoir ?) -> on n'avait pas seulement une perte de précision mais des dépassements -> pas admissible d'avoir des données fausses




    \subsection{Arithmétique fixed point}
 

    % Pas trop de C++ parce que faire un objet avec plein d'accessors, ce n'est pas très optimisé (on se retrouve avec un gros objet avec plein de variables). Derrière on fait de l'assembleur => il y a un trop grand écart. D'habitude les codesc audio sotn codés en C mais c'est aussi peut-être juste pour une raison historique.



    \section{Optimisations à l'architecture ARM}
    \subsection{Spécificités de l'architecture ARMv8}
    \paragraph{}
    Globalement reprend les tutos ARM
    % FFT déjà optimisées pour Neon mais limitations sur ce qui entre et ce qui sort
    % \subsubsection{FFT de la librairie Ne10}

    \subsection{Utilisation des fonctions Neon SIMD (intrinsic)}
    % instructions principales utilisées + contraintes associées : types d'entrée + sortie -> comment ça s'agence avec le reste
    % \begin{itemize}
    %     \item voir la doc de neon \url{https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/What-is-SIMD-/ARM-SIMD-instructions}
    %     \item voir comment faire ce qui doit être fait en fonction des instructions SIMD dispo : souvent il faut ranger correctement, splitter les registres correctement
    %     \item utilisation des instructions intrinsèques de GCC \url{https://fr.wikipedia.org/wiki/Fonction_intrins%C3%A8que}
    % \end{itemize}

    \paragraph{}
    Les opérations SIMD permettent de faire plusieurs opérations en une fois où l'algo normal n'en fait qu'une à la fois. L'algo SIMD permet de faire plusieurs modifications à la fois -> il faut ranger les données de manière à pouvoir l'appliquer facilement (fonction fenêtre -> tri des données ? )


    \paragraph{}
    Plus les données sur lesquelles on travaille sont petites, plus on peut faire d'opérations en parallèle -> il faut voir si la perte de précision est ok. -> mettre une représentation graphique, c'est beaucoup plus simple à comprendre. D'où l'intérêt de passer à du 16 bits, plutôt que de rester en 32 bits et il faut absolument éviter le 64 bits (aucun intérêt).

    Attention au flag pour la compilation + au header (accès aux intrinsics pas activé par défaut)


    \newpage
    \section{Analyse des résultats}
    \subsection{Validation des données}
    \label{sec:validation}
    \paragraph{}
    Les sections précédentes ont montré que la les différentes itérations de la MDCT développées ont été validées à chaque étape. Cette validation consiste essentiellement en une vérification manuelle des données de sortie de la MDCT : avec un signal sinusoïdal connu en entrée, il est facile de vérifier que l'analyse fréquentielle ne contient bien qu'une seule composante fréquentielle, que la vérification se fasse en lisant les données brutes à la sortie de l'algorithme ou par une analyse graphique de celle-ci.

    \paragraph{}
    %La MDCT a également été validée par comparaison de ses données de sortie avec des algorithmes de référence : les implémentations de la formule mathématique de la MDCT présentée dans les annexes \ref{an:ref_mdct_float} pour l'implémentation en arithmétique \emph{floating point} et \ref{an:ref_mdct_int} en \emph{fixed point}.

    \paragraph{}
    Ces tests auraient pu être améliorés en automatisant la vérification, e.g. en générant une fois les données de référence attendues pour permettre le développement d'un code de test qui compare automatiquement les données de références avec les données à vérifier. En effet, devoir relancer les tests et vérifier les données à chaque fois qu'une modification est faite dans le code peut s'avérer laborieux et mettre en place des tests automatiques aurait permis de gagner un temps précieux.


    %     Réaliser une fonction qui calcule la somme des cosinus (formule de wikipedia) pour chaque samples (pas du tout optimisée donc super lente). Pour la calcul en integer, on peut autoriser un manque de précision de max 1 LSB.



    % \paragraph{}
    % Pour les codecs c'est important de garder l'implémentation de référence mais à un moment on ne peut plus tester sur l'architecture intel. En pratique on utilise des pointeurs de fonction à déréférencer pour appeler l'implémentation voulue. En fonction du CPU ID, on sait quelles instructions on utilise. Au runtime, on choisit une ou l'autre implémentation en fonction de l'architecture, e.g. certains ARM n'ont pas les routines NEON



    \subsection{Gain en performance}
    \paragraph{}
    La mesure des performances a pour but de valider le bloc MDCT avant de l'intégrer au codec AAC. Le cahier des charges du stage ne contenait pas d'objectif à atteindre en terme de performance, ni absolu (e.g. un temps d'exécution maximal à respecter dans des conditions données), ni relatif (e.g. gagner un certain pourcentage de performances par rapport à une MDCT de référence).

    \paragraph{}
    L'objectif en terme de temps d'exécution n'étant pas fini, il a été décidé de tenter de gagner le maximum de performances sur le temps de mon stage. Le critère de réussite est dès lors d'obtenir des performances au moins équivalentes pour la version finale de la MDCT que pour ses versions moins optimisées. Le temps d'exécution de la MDCT \emph{fixed point} doit évidemment être inférieur au temps d'exécution de l'algorithme de référence puisque celui-ci ne contient aucune optimisation. Ce temps peut toutefois être équivalent au temps d'exécution de la MDCT \emph{floating point} : à performances équivalentes, l'algorithme \emph{fixed point} rendra tout de même l'encodeur AAC plus performant en économisant les conversions \emph{integer}-\emph{floating point} à l'entrée et à la sortie du bloc MDCT. En effet, les données sont reçues par la MDCT en \emph{integer} et devront être traitées en \emph{integer} par le bloc de quantification à la sortie de la MDCT.
    
    \paragraph{}
    Le temps d'exécution de la MDCT a été mesuré sur base du code de l'annexe \ref{an:run_mdcts} compilé par les commandes CMake présentée à l'annexe \ref{an:cmake_run_mdcts}. Le code permet de générer plusieurs exécutables en fonction de la variable d'environnement définie. Par défaut, l'exécutable permet de mesurer le temps d'exécution de de l'algorithme de référence en , plusieurs exécutables sont générés, chacun d'eux permettant d'exécuter l'algorithme MDCT un certain nombre de fois (donné en paramètre à l'exécution). La fréquence du signal sinusoïdal utilisé en entrée de la MDCT peut également être donnée en paramètre mais elle ne varie pas entre les différentes exécutions afin de ne pas introduire d'aléatoire dans les mesures.

    \paragraph{}
    L'annexe  En fonction du paramètre défini à la création des exécutables, le code exécuté sera celui de la MDCT de référence en \emph{double floating point} (paramètre \texttt{-DREF}) ou de la MDCT basée sur la FFT de la librairie Ne10 en \emph{floating point} (paramètre \texttt{-DFLOATING\_POINT}) ou en \emph{fixed point} en \emph{plain C} (paramètre \texttt{-DFLOATING\_POINT}) 


    perfs de la MDCT basée sur la FFT de FFTW3 en f32 pour comparaison :
    average run time:   7686.56 ns
    standard deviation: 6.61219e-07 ns
 
    % Comparaison avec un implémentation de référence plain c mais aussi à titre indicatif avec l'algorithme de référence car le plain c est déjà optimisé


    % L'impact de la window function : exemple avec un sinus : les composantes fréquentielles du sinus ressortent beaucoup mieux.

    % +difficultés au niveau des performances pas bonnes jusqu'à la fin

    % projet compilé en release pour les tests de perf

    \subsection{Perte de précision}
    % Comparaison avec l'algorithme de référence
    % Annexe : algo de référence, test de comparaison, résultats avec des données aléatoires et avec un sinus simple

    \newpage
    \section{Améliorations possibles}
    \begin{itemize}
        \item Fonction fenêtre intégrée aux opérations de pre twiddling
        \item Quantification intégrée au post twiddling
        \item tests automatisés
        \item code en C
        \item tests de performances plus poussés avec comparaison avec un algo existant
    \end{itemize}
    % Améliorations encore possible : faire les premières opérations de prétwiddling en Q15 8 par 8 avant de splitter, mêler les facteurs de la fenêtre aux facteurs de twiddling


    % DIFFICULTES
    % - calculs en Qx.x
    % - implémentation avec Ne10 car format de sortie, headroom et autres infos utiles pas documentées

    \newpage
    \section*{Conclusion}
    \addcontentsline{toc}{section}{\protect\numberline{}Conclusion}
    \paragraph{}
    Sur base du cahier des charges de début de stage, il a été décidé que mon travail s
    % Résultats obtenus + améliorations possibles

    \bibliography{biblio} 
    \bibliographystyle{ieeetr.bst}
    \addcontentsline{toc}{section}{\protect\numberline{}Références}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \newpage
    \setcounter{page}{1}
    \pagenumbering{Roman}

    \appendix
    \setcounter{section}{1}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 5 Environnement de développement
    %       - an:cmake_super
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \asection{CMake principal}\label{an:cmake_super}
    \paragraph{}
    Fichier CMake principal placé à la racine du projet. Il permet de compiler :
    \begin{itemize}
        \item le projet \emph{audio\_encoding} contenant les différentes MDCT et leurs tests : les commandes CMake de ce sous projet sont présentées dans les annexes suivantes sous le code qu'elles permettent de compiler;
        \item la librairie \emph{Ne10} : les variables \texttt{NE10\_LINUX\_TARGET\_ARCH} et \texttt{GNULINUX\_PLATFORM} sont initialisées conformément aux recommendations de la documentation pour la compilation de la librairie.
    \end{itemize}
    \begin{lstlisting}
cmake_minimum_required(VERSION 3.13)

set(NE10_LINUX_TARGET_ARCH armv7)
set(GNULINUX_PLATFORM ON)
if (CMAKE_BUILD_TYPE STREQUAL "DEBUG")
    set(BUILD_DEBUG ON)
endif (CMAKE_BUILD_TYPE STREQUAL "DEBUG")

add_subdirectory(audio_encoding)
add_subdirectory(Ne10)
    \end{lstlisting}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 6 Algorithmes MDCT de référence
    %   6.2 Implémentations des MDCT de référence en algorithmiques floating point et fixed point
    %       - an:mdct_const
    %       - an:mdct_ref
    %           - an:mdct_ref_float
    %           - an:mdct_ref_int
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \asection{Valeurs constantes des MDCT}\label{an:mdct_const}
    \paragraph{}
    Le fichier \texttt{mdct\_constants.h} rassemble les valeurs constantes des MDCT pour une fenêtre d'entrée de 1024 échantillons.
    \begin{lstlisting}
// Sampling frequency: 48kHz
#define FS                  48000

// Window length and derived constants
#define MDCT_WINDON_LEN     1024
#define MDCT_M              (MDCT_WINDON_LEN>>1)    // spectrum size
#define MDCT_M2             (MDCT_WINDON_LEN>>2)    // fft size
#define MDCT_M4             (MDCT_WINDON_LEN>>3)
#define MDCT_M32            (3*(MDCT_WINDON_LEN>>2))
#define MDCT_M52            (5*(MDCT_WINDON_LEN>>2))
    \end{lstlisting}

    \asection{Algorithmes de référence}\label{an:mdct_ref}
    \asubsection{MDCT de référence en \emph{float}}\label{an:mdct_ref_float}
    \paragraph{}
    Algorithme de référence de la MDCT basé sur la formule mathématique de la MDCT. Le template permet de réaliser les calculs en \emph{float} ou en \emph{double}.
    \begin{lstlisting}
#include <cmath>

#include "mdct_constants.h"

template<typename FLOAT>
void ref_float_mdct(FLOAT *time_signal, FLOAT *spectrum)
{
    FLOAT scale = 2.0 / sqrt(MDCT_WINDON_LEN);
    FLOAT factor1 = 2.0 * M_PI / static_cast<FLOAT>(MDCT_WINDON_LEN);
    FLOAT factor2 = 0.5 + static_cast<FLOAT>(MDCT_M2);
    for (int k = 0; k < MDCT_M; ++k)
    {
        FLOAT result = 0.0;
        FLOAT factor3 = (k + 0.5) * factor1;
        for (int n = 0; n < MDCT_WINDON_LEN; ++n)
        {
            result += time_signal[n] * cos((static_cast<FLOAT>(n) + factor2) * factor3);
        }
        spectrum[k] = scale * result;
    }
}
    \end{lstlisting}
    \asubsection{MDCT de référence en \emph{integer}}\label{an:mdct_ref_int}
    \paragraph{}
    Algorithme de référence de la MDCT basé sur la formule mathématique de la MDCT. Le spectre est calculé en \emph{double} puis convertit en \emph{integer} sur 32 bits.
    \begin{lstlisting}
#include <cassert>

#include "ref_mdct.h"

void ref_int_mdct(int16_t *time_signal, int32_t *spectrum)
{
    double scale = sqrt(MDCT_WINDON_LEN) / 2.0;     // MDCT scale (2/sqrt(WIN_LEN)) + Q15 scale
    double factor1 = 2.0 * M_PI / MDCT_WINDON_LEN;
    double factor2 = 0.5 + MDCT_M2;
    for (int k = 0; k < MDCT_M; ++k)
    {
        double result = 0.0;
        double factor3 = (k + 0.5) * factor1;
        for (int n = 0; n < MDCT_WINDON_LEN; ++n)
        {
            result += time_signal[n] * cos((n + factor2) * factor3);
        }
        assert(round(result*scale) == static_cast<int32_t>(round(result*scale)));
        spectrum[k] = static_cast<int32_t>(round(result/scale));
    }
}
    \end{lstlisting}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %   6.3 Validation des algorithmes de référence
    %       - an:sin_wave
    %           - an:sin_wave_float
    %           - an:sin_wave_int
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \asection{Génération d'un signal sinusoïdal}\label{an:sin_wave}
    \asubsection{Génération d'un signal sinusoïdal en \emph{float}}\label{an:sin_wave_float}
    \paragraph{}
    Code de génération d'un signal sinusoïdal en \emph{float} ou en \emph{double}.
    \begin{lstlisting}
#include <cmath>

template<typename FLOAT>
void sin_float(FLOAT *out, int n_samples, double amplitude,
    double frequency, double phase_shift, int sampling_frequency)
{
    FLOAT omega = 2.0 * M_PI * frequency / static_cast<FLOAT>(sampling_frequency);
    for (int i = 0; i < n_samples; ++i)
    {
        out[i] = amplitude * sin(static_cast<FLOAT>(i) * omega + phase_shift);
    }
}
    \end{lstlisting}

    \asubsection{Génération d'un signal sinusoïdal en \emph{integer}}\label{an:run_ref_mdct_fint}
    \paragraph{}
    La génération du signal sinusoïdal en \emph{integer} fait appel à la génération du signal sinusoïdal en \emph{double} avant de convertir le résultat en \emph{integer} (représentation Q15).
    \begin{lstlisting}
#include <cstring>

#include "sin_wave.h"

void sin_int(int16_t *out, int n_samples, double amplitude,
    double frequency, double phase_shift, int sampling_frequency)
{
    double scale = 1.0;
    if (abs(amplitude) < 1.0) scale *= amplitude;

    double *temp_sin = static_cast<double *>(malloc(n_samples*sizeof(double)));
    memset(temp_sin, 0, n_samples*sizeof(double));

    sin_float<double>(temp_sin, n_samples, scale, frequency, phase_shift, sampling_frequency);

    for (int i = 0; i < n_samples; ++i)
    {
        out[i] = static_cast<int16_t>(temp_sin[i]*pow(2.0, 15.0));
    }
}
    \end{lstlisting}


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 7 Algorithme MDCT basé sur la FFT
    %   7.2 Implémentation de la MDCT basée sur la FFT de la librairie FFTW3
    %       - an:mdct_fftw3_f32_header
    %       - an:mdct_fftw3_f32_constructeur
    %       - an:mdct_fftw3_f32_destructeur
    %       - an:mdct_fftw3_f32_func
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \asection{Implémentation de la MDCT basée sur la FFT de \emph{FFTW3}}\label{an:mdct_fftw3_f32}
    \asubsection{Header}\label{an:mdct_fftw3_f32_header}
    \paragraph{}
    Header de la classe \texttt{mdct\_fftw3\_f32} : MDCT basée sur la FFT de la librairie \emph{FFTW3} en \emph{float} (32 bits). La classe contient les structures de données \texttt{fft\_in} et \texttt{fft\_out}, le tableau de facteurs de \texttt{twiddle} utilisé pour le pre- et le post-processing et la configuration de la FFT (\texttt{fft\_plan}). L'implémentation des ses fonction est présenté dans les annexes suivantes.
    \begin{lstlisting}
#include <fftw3.h>

#include "mdct_constants.h"

class fftw3_mdct_f32
{
private:
    fftwf_plan fft_plan;      // FFT configuration
    fftwf_complex *fft_in;    // FFT input buffer
    fftwf_complex *fft_out;   // FFT output buffer
    float twiddle[MDCT_M];

public:
    fftw3_mdct_f32();
    ~fftw3_mdct_f32();
    void mdct(float *time_signal, float *spectrum);
    void imdct(float *spectrum, float *time_signal);
};
    \end{lstlisting}

    \asubsection{Constructeur}\label{an:mdct_fftw3_f32_constructor}
    \paragraph{}
    Initialisation de la MDCT dans le constructeur de la classe \texttt{mdct\_fftw3\_f32} :
    \begin{itemize}
        \item Le tableau de \texttt{twiddle} est initialisé en \emph{float} sur 32 bits;
        \item La FFT de \emph{FFTW3} est initialisée en une dimension (pour l'audio) avec la taille de la FFT réduite à un quart de la taille de la fenêtre d'entrée par le pre-processing et avec l'option \texttt{FFTW\_MEASURE} plus lente à l'initialisation mais qui permet d'optimiser le temps d'exécution de la FFT;
        \item Les tableaux contenant les données d'entrée (\texttt{fft\_in}) et de sortie (\texttt{fft\_out}) de la FFT sont alloués dynamiquement avec la fonction de \emph{FFTW3} et ils sont passé en paramètre à la configuration de la FFT.
    \end{itemize}
    \begin{lstlisting}
#include <cmath>

fftw3_mdct_f32::fftw3_mdct_f32()
{
    float alpha = M_PI / (8.f * MDCT_M);
    float omega = M_PI / MDCT_M;
    float scale = sqrt(sqrt(2.f / MDCT_M));

    for (int i = 0; i < MDCT_M2; ++i)
    {
        float x = omega*i + alpha;
        twiddle[2*i] = scale * cos(x);
        twiddle[2*i+1] = scale * sin(x);
    }

    fft_in = (fftwf_complex *)fftwf_malloc(sizeof(fftwf_complex) * MDCT_M2);
    fft_out = (fftwf_complex *)fftwf_malloc(sizeof(fftwf_complex) * MDCT_M2);
    fft_plan = fftwf_plan_dft_1d(MDCT_M2, fft_in, fft_out, FFTW_FORWARD, FFTW_MEASURE);
}
    \end{lstlisting}

    \asubsection{Destructeur}\label{an:mdct_fftw3_f32_destructor}
    \paragraph{}
    Destructeur de la classe \texttt{mdct\_fftw3\_f32} qui permet de libérer la mémoire allouée aux tableaux d'entrée et de sortie de la FFT et à sa configuration avec les fonctions de la librairie \emph{FFTW3}.
    \begin{lstlisting}
fftw3_mdct_f32::~fftw3_mdct_f32()
{
    fftwf_destroy_plan(fft_plan);
    fftwf_free(fft_in);
    fftwf_free(fft_out);
}
    \end{lstlisting}

    \asubsection{Fonction MDCT}\label{an:mdct_fftw3_f32_func}
    \paragraph{}
    Implémentation de l'algorithme de MDCT basé sur la FFT de la librairie \emph{FFTW3} :
    \begin{itemize}
        \item Initialisation du tableau d'entrée de la FFT : les opérations de \emph{pre-twiddling} permettent de réduire la fenêtre d'entrée de la FFT;
        \item Appel de la fonction FFT de \emph{FFTW3};
        \item Calcul du spectre de fréquence : les opérations de \emph{post-twiddling} permettent de calculer le spectre à partir des données de sortie de la FFT et des facteurs de \emph{twiddle}.
    \end{itemize}
    \begin{lstlisting}
void fftw3_mdct_f32::mdct(float *time_signal, float *spectrum)
{
    float *cos_tw = twiddle;
    float *sin_tw = cos_tw + 1;

    /* odd/even folding and pre-twiddle */
    float *xr = (float *)fft_in;
    float *xi = xr + 1;

    for (int i = 0; i < MDCT_M2; i += 2)
    {
        float r0 = time_signal[MDCT_M32-1-i] + time_signal[MDCT_M32+i];
        float i0 = time_signal[MDCT_M2+i] - time_signal[MDCT_M2-1-i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        xr[i] = r0*c + i0*s;
        xi[i] = i0*c - r0*s;
    }

    for(int i = MDCT_M2; i < MDCT_M; i += 2)
    {
        float r0 = time_signal[MDCT_M32-1-i] - time_signal[-MDCT_M2+i];
        float i0 = time_signal[MDCT_M2+i] + time_signal[MDCT_M52-1-i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        xr[i] = r0*c + i0*s;
        xi[i] = i0*c - r0*s;
    }

    /* complex FFT of size MDCT_M2 */
    fftwf_execute(fft_plan);

    /* post-twiddle */
    xr = (float *)fft_out;
    xi = xr + 1;

    for (int i = 0; i < MDCT_M; i += 2)
    {
        float r0 = xr[i];
        float i0 = xi[i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        spectrum[i] = -r0*c - i0*s;
        spectrum[MDCT_M-1-i] = -r0*s + i0*c;
    }
}
    \end{lstlisting}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %   7.3 Validation
    %       - an:fftw3_example
    %           - an:fftw3_example_code
    %           - an:fftw3_example_compilation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \asection{Validation de la MDCT \emph{FFTW3} en \emph{float 32}}\label{an:fftw3_example}
    \asubsection{Code source}\label{an:fftw3_example_code}
    \paragraph{}
    Test de la MDCT basée sur la FFT de \emph{} avec un signal d'entrée sinusoïdal à 200Hz :
    \begin{itemize}
        \item Génération et affichage d'un signal sinusoïdal à 200Hz;
        \item Calcul et affichage du spectre de fréquences de ce signal;
        \item Opération inverse de la MDCT et affichage du signal temporel calculé à partir du spectre.
    \end{itemize}
    \begin{lstlisting}
#include <iomanip>
#include <iostream>

#include <cstring>

#include "mdct_constants.h"
#include "fftw3_mdct_f32.h"
#include "sin_wave.h"

/**
    * @brief MDCT algorithm calling the FFT of the fftw3 library
    * Code based on https://www.dsprelated.com/showcode/196.php
    */
int main(void)
{
    float time_in[MDCT_WINDON_LEN];        // input time signal
    sin_float(time_in, MDCT_WINDON_LEN, 0.9, 200.0, 0.0, FS);

    float time_out[MDCT_WINDON_LEN];       // output time signal (generated by the IMDCT)
    memset(time_out, 0, MDCT_WINDON_LEN*sizeof(float));

    float spectrum[MDCT_M];    // frequency spectrum
    memset(spectrum, 0, MDCT_M*sizeof(float));

    fftw3_mdct_f32 fftw3_mdct;
    fftw3_mdct.mdct(time_in, spectrum);
    fftw3_mdct.imdct(spectrum, time_out);

    for (int i = 0; i < MDCT_WINDON_LEN; ++i)
    {
        std::cout << "time_in[" << std::setw(4) << i << "]" << std::setw(12) << time_in[i]
            << " | time_out[" << std::setw(4) << i << "]" << std::setw(12) << time_out[i]
            << std::endl;
    }
    std::cout << std::endl;

    for (int i = 0; i < MDCT_M; ++i)
    {
        std::cout << "spectrum[" << std::setw(4) << i << "]"
            << std::setw(12) << spectrum[i] << std::endl;
    }
    std::cout << std::endl;

    return 0;
}
    \end{lstlisting}

    \asubsection{Compilation}\label{an:fftw3_example_compilation}
    \paragraph{}
    Commandes CMake permettant de compiler le code d'exemple.
    \begin{lstlisting}
# MDCT using the fftw3 library f32
add_executable(fftw3_mdct_f32 test/validation/fftw3_example.cpp
    src/fftw3_mdct_f32.cpp src/sin_wave.cpp)
target_link_libraries(fftw3_mdct_f32 fftw3f)
    \end{lstlisting}


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 8 Intégration de la librairie Ne10
    %   8.2 Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique floating point
    %       - an:mdct_ne10_f32
    %           - an:mdct_ne10_f32_header
    %           - an:mdct_ne10_f32_constructor
    %           - an:mdct_ne10_f32_destructor
    %           - an:mdct_ne10_f32_func
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \asection{Implémentation de la MDCT basée sur la FFT de \emph{Ne10} en \emph{floating point}}\label{an:mdct_ne10_f32}
    \asubsection{Header}\label{an:mdct_ne10_f32_header}
    \paragraph{}
    Header de la classe \texttt{mdct\_ne10\_f32\_c} : MDCT basée sur la FFT de la librairie \emph{Ne10} en \emph{float} (32 bits). La classe contient les structures de données \texttt{fft\_in} et \texttt{fft\_out}, le tableau de facteurs de \texttt{twiddle} utilisé pour le pre- et le post-processing et la configuration de la FFT (\texttt{cfg}). L'implémentation des ses fonction est présenté dans les annexes suivantes.
    \begin{lstlisting}
#pragma once

#include "mdct_constants.h"
#include "NE10.h"

class ne10_mdct_f32_c
{
private:
    ne10_fft_cfg_float32_t cfg;                                          // Ne10 configuration
    ne10_fft_cpx_float32_t fft_in[MDCT_M2]__attribute__((aligned(16)));  // Ne10 FFT input buffer
    ne10_fft_cpx_float32_t fft_out[MDCT_M2]__attribute__((aligned(16))); // Ne10 FFT output buffer
    float twiddle[MDCT_M]__attribute__((aligned(16)));                   // twiddle factors

public:
    ne10_mdct_f32_c();
    ~ne10_mdct_f32_c();
    void mdct(float *time_signal, float *spectrum);
};
    \end{lstlisting}

    \asubsection{Constructeur}\label{an:mdct_ne10_f32_constructor}
    \paragraph{}
    Initialisation de la MDCT dans le constructeur de la classe \texttt{mdct\_ne10\_f32\_c} :
    \begin{itemize}
        \item Le tableau de \texttt{twiddle} est initialisé en \emph{float} sur 32 bits;
        \item La configuration de la FFT de \emph{Ne10} est initialisée an \emph{complex to complex} en \emph{float 32} avec en paramètre la taille de la fenêtre de la FFT réduite à un quart de la taille de la fenêtre d'entrée.
    \end{itemize}
    \begin{lstlisting}
ne10_mdct_f32_c::ne10_mdct_f32_c()
{
    float alpha = M_PI / (8.0 * static_cast<float>(MDCT_M));
    float omega = M_PI / static_cast<float>(MDCT_M);
    float scale = sqrt(sqrt(2.0 / static_cast<float>(MDCT_M)));
    for (int i = 0; i < MDCT_M2; ++i) 
    {
        float x = omega * i + alpha;
        twiddle[2*i] = static_cast<float>(scale * cos(x));
        twiddle[2*i+1] = static_cast<float>(scale * sin(x));
    }

    cfg = ne10_fft_alloc_c2c_float32_c(MDCT_M2);
}
    \end{lstlisting}

    \asubsection{Destructeur}\label{an:mdct_ne10_f32_destructor}
    \paragraph{}
    Destructeur de la classe \texttt{mdct\_ne10\_f32\_c} qui permet de libérer la mémoire allouée à la configuration de la FFT avec la fonction appropriée de la librairie \emph{Ne10}.
    \begin{lstlisting}
ne10_mdct_f32_c::~ne10_mdct_f32_c()
{
    ne10_fft_destroy_c2c_float32(cfg);
}
    \end{lstlisting}

    \asubsection{Fonction MDCT}\label{an:mdct_ne10_f32_func}
    \paragraph{}
    Implémentation de l'algorithme de MDCT basé sur la FFT de la librairie \emph{Ne10} en \emph{float 32} et en \emph{plain C} :
    \begin{itemize}
        \item Initialisation du tableau d'entrée de la FFT : les opérations de \emph{pre-twiddling} permettent de réduire la fenêtre d'entrée de la FFT;
        \item Appel de la fonction FFT de \emph{Ne10};
        \item Calcul du spectre de fréquence : les opérations de \emph{post-twiddling} permettent de calculer le spectre à partir des données de sortie de la FFT et des facteurs de \emph{twiddle}.
    \end{itemize}
    \begin{lstlisting}
void ne10_mdct_f32_c::mdct(float *time_signal, float *spectrum)
{
    // pre-twiddling
    float *cos_tw = twiddle;
    float *sin_tw = cos_tw + 1;
    for (int i = 0; i < MDCT_M2; i += 2)
    {
        float r0 = time_signal[MDCT_M32-1-i] + time_signal[MDCT_M32+i];
        float i0 = time_signal[MDCT_M2+i] - time_signal[MDCT_M2-1-i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        fft_in[i/2].r = r0*c + i0*s;
        fft_in[i/2].i = i0*c - r0*s;
    }

    for (int i = MDCT_M2; i < (MDCT_M); i += 2)
    {
        float r0 = time_signal[MDCT_M32-1-i] - time_signal[-MDCT_M2+i];
        float i0 = time_signal[MDCT_M2+i] + time_signal[MDCT_M52-1-i];

        float c = cos_tw[i];
        float s = sin_tw[i];

        fft_in[i/2].r = r0*c + i0*s;
        fft_in[i/2].i = i0*c - r0*s;
    }

    // FFT
    ne10_fft_c2c_1d_float32_c(fft_out, fft_in, cfg, 0);

    // post-twiddling
    for (int i = 0; i < (MDCT_M); i += 2)
    {
        float r0 = fft_out[i/2].r;
        float i0 = fft_out[i/2].i;

        float c = cos_tw[i];
        float s = sin_tw[i];

        spectrum[i] = -r0*c - i0*s;
        spectrum[(MDCT_M)-1-i] = -r0*s + i0*c;
    }
}
    \end{lstlisting}


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 9 Algorithme MDCT en arithmétique fixed point
    %   9.3 Implémentation de la MDCT basée sur la FFT Ne10 en arithmétique fixed point
    %       - an:mdct_ne10_i32_c
    %           - an:mdct_ne10_i32_c_header
    %           - an:mdct_ne10_i32_c_constructor
    %           - an:mdct_ne10_i32_c_destructor
    %           - an:mdct_ne10_i32_c_func
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \asection{Implémentation de la MDCT basée sur la FFT de \emph{Ne10} en \emph{fixed point}}\label{an:mdct_ne10_i32_c}
    \asubsection{Header}\label{an:mdct_ne10_i32_c_header}
    Header de la classe \texttt{mdct\_ne10\_i32\_c} : MDCT basée sur la FFT de la librairie \emph{Ne10} en \emph{integer} (32 bits). La classe contient les structures de données \texttt{fft\_in} en représentation Q1.15 et \texttt{fft\_out} en Q9.15, le tableau de facteurs de \texttt{twiddle} utilisé pour le pre- et le post-processing et la configuration de la FFT (\texttt{cfg}). L'implémentation des ses fonction est présenté dans les annexes suivantes.
    \paragraph{}
    \begin{lstlisting}
#pragma once

#include "mdct_constants.h"
#include "NE10.h"

class ne10_mdct_i32_c
{
private:
    ne10_fft_cfg_int32_t cfg;                                          // Ne10 configuration
    ne10_fft_cpx_int32_t fft_in[MDCT_M2]__attribute__((aligned(16)));  // Ne10 FFT input buffer Q1.15
    ne10_fft_cpx_int32_t fft_out[MDCT_M2]__attribute__((aligned(16))); // Ne10 FFT output buffer Q9.15
    int16_t twiddle[MDCT_M]__attribute__((aligned(16)));               // MDCT twiddle factors

public:
    ne10_mdct_i32_c();
    ~ne10_mdct_i32_c();
    void mdct(int16_t *time_signal, int32_t *spectrum);
};
    \end{lstlisting}

    \asubsection{Constructeur}\label{an:mdct_ne10_i32_c_constructor}
    \paragraph{}
    Initialisation de la MDCT dans le constructeur de la classe \texttt{mdct\_ne10\_i32\_c} :
    \begin{itemize}
        \item Le tableau de \texttt{twiddle} est initialisé en \emph{double} puis converti en \emph{integer} (représentation Q15);
        \item La configuration de la FFT de \emph{Ne10} est initialisée an \emph{complex to complex} en \emph{integer 32} avec en paramètre la taille de la fenêtre de la FFT réduite à un quart de la taille de la fenêtre d'entrée.
    \end{itemize}
    \begin{lstlisting}
ne10_mdct_i32_c::ne10_mdct_i32_c()
{
    // intialize the twiddling factors
    double alpha = M_PI / (8.0*MDCT_M);
    double omega = M_PI / MDCT_M;
    double scale = sqrt(sqrt(2.0 / static_cast<double>MDCT_M));
    for (int i = 0; i < MDCT_M2; ++i)
    {
        double x = omega * i + alpha;
        twiddle[2*i] = static_cast<int16_t>(cos(x)*scale*pow(2.0, 15.0));
        twiddle[2*i+1] = static_cast<int16_t>(sin(x)*scale*pow(2.0, 15.0));
    }

    // initialize the Ne10 FFT configuration
    cfg = ne10_fft_alloc_c2c_int32_c(MDCT_M2);
}
    \end{lstlisting}

    \asubsection{Destructeur}\label{an:mdct_ne10_i32_c_destructor}
    \paragraph{}
    Destructeur de la classe \texttt{mdct\_ne10\_i32\_c} qui permet de libérer la mémoire allouée à la configuration de la FFT avec la fonction appropriée de la librairie \emph{Ne10}.
    \begin{lstlisting}
ne10_mdct_i32_c::~ne10_mdct_i32_c()
{
    ne10_fft_destroy_c2c_int32(cfg);
}
    \end{lstlisting}

    \asubsection{Fonction MDCT}\label{an:mdct_ne10_i32_c_func}
    \paragraph{}
    Implémentation de l'algorithme de MDCT basé sur la FFT de la librairie \emph{Ne10} en \emph{integer 32} et en \emph{plain C} :
    \begin{itemize}
        \item Initialisation du tableau d'entrée de la FFT : les opérations de \emph{pre-twiddling} permettant de réduire la fenêtre d'entrée de la FFT sont faites en algorithmique \emph{fixed point};
        \item Appel de la fonction FFT de \emph{Ne10};
        \item Calcul du spectre de fréquence : les opérations de \emph{post-twiddling} permettant de calculer le spectre à partir des données de sortie de la FFT et des facteurs de \emph{twiddle} sont faites en algorithmique \emph{fixed point}.
    \end{itemize}
    \begin{lstlisting}
void ne10_mdct_i32_c::mdct(int16_t *time_signal, int32_t *spectrum)
{
    // pre-twiddling
    // fft_in = (Q1.15 + Q1.15) * Q1.15/4 + (Q1.15 + Q1.15) * Q1.15/4
    //          1/4 Q1.30 + 1/4 Q1.30 + 1/4 Q1.30 + 1/4 Q1.30 -> Q1.30
    //          >>7 -> Q1.23 + 8 bits reserved for the FFT
    int16_t *cos_tw = twiddle;
    int16_t *sin_tw = cos_tw + 1;
    for (int i = 0; i < MDCT_M2; i += 2)
    {
        int32_t r0 = static_cast<int32_t>(time_signal[MDCT_M32-1-i]) + time_signal[MDCT_M32+i];
        int32_t i0 = static_cast<int32_t>(time_signal[MDCT_M2+i]) - time_signal[MDCT_M2-1-i];

        int16_t c = cos_tw[i];
        int16_t s = sin_tw[i];

        fft_in[i/2].r = (((r0*c)+64)>>7) + (((i0*s)+64)>>7);
        fft_in[i/2].i = (((i0*c)+64)>>7) - (((r0*s)+64)>>7);
    }

    for (int i = MDCT_M2; i < MDCT_M; i += 2)
    {
        int32_t r0 = static_cast<int32_t>(time_signal[MDCT_M32-1-i]) - time_signal[-MDCT_M2+i];
        int32_t i0 = static_cast<int32_t>(time_signal[MDCT_M2+i]) + time_signal[MDCT_M52-1-i];

        int16_t c = cos_tw[i];
        int16_t s = sin_tw[i];

        fft_in[i/2].r = (((r0*c)+64)>>7) + (((i0*s)+64)>>7);
        fft_in[i/2].i = (((i0*c)+64)>>7) - (((r0*s)+64)>>7);
    }

    // perform the FFT
    ne10_fft_c2c_1d_int32_c(fft_out, fft_in, cfg, 0, 0);

    // post-twiddling
    // spectrum = Q9.23>>8 * Q1.15/4 + Q9.23>>8 * Q1.15/4
    //          = Q9.15 * Q1.15/4 + Q9.15 * Q1.15/4
    //          = Q10.30/4 + Q10.30/4
    //          = Q11.30/4
    //          = Q9.30 >> 15 = Q9.15
    for (int i = 0; i < MDCT_M; i += 2)
    {
        int32_t r0 = fft_out[i/2].r;
        int32_t i0 = fft_out[i/2].i;

        int16_t c = cos_tw[i];
        int16_t s = sin_tw[i];

        spectrum[i] = ((((-r0+128)>>8)*c+16384)>>15) - ((((i0+128)>>8)*s+16384)>>15);
        spectrum[MDCT_M-1-i] = ((((-r0+128)>>8)*s+16384)>>15) + ((((i0+128)>>8)*c+16384)>>15);
    }
}
    \end{lstlisting}


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \asection{}\label{}
    \paragraph{}
    \begin{lstlisting}
    \end{lstlisting}



        \section{Test des performances des algorithmes MDCT}
        \subsection{Code utilisé pour la mesure des performances}
        \label{an:run_mdcts}
        \begin{lstlisting}
#include <iomanip>
#include <iostream>
#include <cstring>

#include "args_parser.h"
#include "mdct_constants.h"
#include "sin_wave.h"
#include "Timers.h"

using namespace EvsHwLGPL;

#ifdef FIXED_POINT_C    // fixed point arithmetic
#include "ne10_fixed_point_mdct_c.h"

#define INPUT_DATA              int16_t
#define OUTPUT_DATA             int32_t
#define GENERATE_SIN            sin_int
#define MDCT                    ne10_fixed_point_mdct_c

#elif FIXED_POINT_NEON  // fixed point arithmetic
#include "ne10_fixed_point_mdct_neon.h"

#define INPUT_DATA              int16_t
#define OUTPUT_DATA             int32_t
#define GENERATE_SIN            sin_int
#define MDCT                    ne10_fixed_point_mdct_neon

#elif FLOATING_POINT    // floating point arithmetic
#include "ne10_floating_point_mdct.h"

#define INPUT_DATA              double
#define OUTPUT_DATA             double
#define GENERATE_SIN            sin_float
#define MDCT                    ne10_floating_point_mdct

#else                   // reference algorithm in floating point arithmetic
#include "reference_mdct.h"

#define INPUT_DATA              double
#define OUTPUT_DATA             double
#define GENERATE_SIN            sin_float

#endif

/**
    * @brief Run the MDCT on a single frame x times
    * the signal is a single tone configurable via the --sin parameter (200Hz by default)
    * the number of runs is setted by the --run parameter (1 by default)
    */
int main(int argc, char **argv) {
    // initialize the parameters
    params p;
    try
    {
        p = parse_args(argc, argv);
    }
    catch(const std::runtime_error &err)
    {
        std::cerr << err.what() << std::endl;
        usage();
        return 1;
    }

    // generate the time signal
    INPUT_DATA time_signal[MDCT_WINDON_LEN]__attribute__((aligned(16)));
    memset(&time_signal, 0, MDCT_WINDON_LEN*sizeof(INPUT_DATA));
    GENERATE_SIN(time_signal, MDCT_WINDON_LEN, 0.9, p.frequency, 0.0, FS);

    OUTPUT_DATA mdct_spectrum[MDCT_M]__attribute__((aligned(16)));
    memset(&mdct_spectrum, 0, MDCT_M*sizeof(OUTPUT_DATA));

    // perform the MDCT
    CTimers timer;
    int64_t sum = 0;
    int64_t *runtimes = static_cast<int64_t *>(malloc(p.runs * sizeof(int64_t)));

#ifdef REF
    for (unsigned i = 0; i < p.runs; ++i) {
        timer.Start();
        ref_float_mdct<double>(time_signal, mdct_spectrum);
        timer.Stop();
        runtimes[i] = timer.GetTimeElapsed();
        sum += timer.GetTimeElapsed();
    }
#else
    MDCT ne10_mdct;
    for (unsigned i = 0; i < p.runs; ++i) {
        timer.Start();
        ne10_mdct.mdct(time_signal, mdct_spectrum);
        timer.Stop();
        runtimes[i] = timer.GetTimeElapsed();
        sum += timer.GetTimeElapsed();
    }
#endif

    // compute the average
    double avg = static_cast<double>(sum) / static_cast<double>(p.runs);
    std::cout << "average run time: " << avg << " ns" << std::endl;

    return 0;
}
        \end{lstlisting}



        \subsection{Commandes CMake générant les exécutables}
        \label{an:cmake_run_mdcts}
        \begin{lstlisting}
# Run the MDCT x times (single frame, floating point)
add_executable(run_mdct_float test/performance/run_mdct.cpp
    src/args_parser src/sin_wave.cpp src/Timers.cpp
    src/ne10_floating_point_mdct.cpp)
target_compile_definitions(run_mdct_float PUBLIC -DFLOATING_POINT)
target_link_libraries(run_mdct_float NE10)

# Run the MDCT x times (single frame, fixed point arithmetic, plain C implementation)
add_executable(run_mdct_fixed_c test/performance/run_mdct.cpp
    src/args_parser src/sin_wave.cpp src/Timers.cpp
    src/ne10_fixed_point_mdct_c.cpp src/ne10_fixed_point_mdct_neon.cpp)
target_compile_definitions(run_mdct_fixed_c PUBLIC -DFIXED_POINT_C)
target_link_libraries(run_mdct_fixed_c NE10)

# Run the MDCT x times (single frame, fixed point arithmetic, neon implementation)
add_executable(run_mdct_fixed_neon test/performance/run_mdct.cpp
    src/args_parser src/sin_wave.cpp src/Timers.cpp
    src/ne10_fixed_point_mdct_c.cpp src/ne10_fixed_point_mdct_neon.cpp)
target_compile_definitions(run_mdct_fixed_neon PUBLIC -DFIXED_POINT_NEON)
target_link_libraries(run_mdct_fixed_neon NE10)

# Run the MDCT x times (single frame, reference algorithm)
add_executable(run_mdct_ref test/performance/run_mdct.cpp
    src/args_parser src/sin_wave.cpp src/Timers.cpp
    src/reference_mdct.cpp)
target_compile_definitions(run_mdct_ref PUBLIC -DREF)
target_link_libraries(run_mdct_ref NE10)
        \end{lstlisting}




\end{document}
